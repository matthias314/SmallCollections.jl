var documenterSearchIndex = {"docs":
[{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"DocTestSetup = quote\n        using SmallCollections\n    # for jldoctest outside of docstrings\n    end","category":"page"},{"location":"#SmallCollections.jl","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections","category":"page"},{"location":"#SmallCollections","page":"SmallCollections.jl","title":"SmallCollections","text":"SmallCollections\n\nThis packages provides several immutable collections that don't allocate and are therefore faster than the usual types. The number of elements that these collections can hold is necessarily limited. At present SmallBitSet and subtypes of AbstractSmallVector are defined.\n\nIf the package BangBang.jl is loaded, then many functions defined by this package are also available in !!-form. For example, setindex!! with a SmallVector as first argument calls setindex.\n\nBounds checking can be skipped for the functions defined in this package by using the @inbounds macro.\n\nSee SmallBitSet, AbstractSmallVector, Base.@inbounds, Section \"BangBang support\".\n\n\n\n\n\n","category":"module"},{"location":"#sec-abstractsmallvector","page":"SmallCollections.jl","title":"AbstractSmallVector","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"AbstractSmallVector\ncapacity(::Type{<:AbstractSmallVector})\nzeros\nones\nsetindex\naddindex\npush(::AbstractSmallVector, ::Vararg)\npop(::AbstractSmallVector)\npushfirst\npopfirst\ninsert\nduplicate\ndeleteat\npopat\nappend\nprepend\nsupport","category":"page"},{"location":"#SmallCollections.AbstractSmallVector","page":"SmallCollections.jl","title":"SmallCollections.AbstractSmallVector","text":"AbstractSmallVector{T} <: AbstractVector{T}\n\nAbstractSmallVector is the supertype of the vector types provided by this module. At present, these are SmallVector and PackedVector. Both are read-only ans can hold a variable number of elements up to a predefined maximal capacity. If the element type T is concrete, then these vector types do not allocate.\n\nSee also SmallVector, PackedVector.\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.capacity-Tuple{Type{<:AbstractSmallVector}}","page":"SmallCollections.jl","title":"SmallCollections.capacity","text":"capacity(::Type{<:AbstractSmallVector}) -> Int\ncapacity(v::AbstractSmallVector) -> Int\n\nReturn the largest number of elements this vector type can hold.\n\n\n\n\n\n","category":"method"},{"location":"#Base.zeros","page":"SmallCollections.jl","title":"Base.zeros","text":"zeros(::Type{V}, n::Integer) where V <: AbstractSmallVector -> V\n\nReturn an AbstractSmallVector of type V containing n zeros.\n\nSee also ones.\n\n\n\n\n\n","category":"function"},{"location":"#Base.ones","page":"SmallCollections.jl","title":"Base.ones","text":"ones(::Type{V}, n::Integer) where V <: AbstractSmallVector -> V\n\nReturn a AbstractSmallVector of type V containing n ones.\n\nSee also zeros.\n\n\n\n\n\n","category":"function"},{"location":"#Base.setindex","page":"SmallCollections.jl","title":"Base.setindex","text":"setindex(v::V, x, i::Integer) where V <: AbstractSmallVector -> V\n\nSubstitute x for the i-th component of v and return the new vector.\n\nSee also Base.setindex,  addindex.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.addindex","page":"SmallCollections.jl","title":"SmallCollections.addindex","text":"addindex(v::V, x, i::Integer) where V <: AbstractSmallVector -> V\n\nAdd x to the i-th component of v and return the new vector.\n\nSee also setindex.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.push-Tuple{AbstractSmallVector, Vararg}","page":"SmallCollections.jl","title":"SmallCollections.push","text":"push(v::V, xs...) where V <: AbstractSmallVector -> V\n\nReturn the AbstractSmallVector obtained from v by appending the arguments xs.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{AbstractSmallVector}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(v::V) where {T, V <: AbstractSmallVector{T}} -> Tuple{V,T}\n\nReturn the tuple (w, x) where x is the last element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pushfirst","page":"SmallCollections.jl","title":"SmallCollections.pushfirst","text":"pushfirst((v::V, xs...) where V <: AbstractSmallVector -> V\n\nReturn the AbstractSmallVector obtained from v by prepending the arguments xs.\n\nSee also Base.pushfirst!, BangBang.pushfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.popfirst","page":"SmallCollections.jl","title":"SmallCollections.popfirst","text":"popfirst(v::V) where {T, V <: AbstractSmallVector{T}} -> Tuple{V,T}\n\nReturn the tuple (w, x) where x is the first element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.popfirst!, BangBang.popfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.insert","page":"SmallCollections.jl","title":"SmallCollections.insert","text":"insert(v::V, i::Integer, x) where V <: AbstractSmallVector{T} -> V\n\nReturn the AbstractSmallVector obtained from v by inserting x at position i. The position i must be between 1 and length(v)+1.\n\nThis is the non-mutating analog of Base.insert!.\n\nSee also duplicate.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.duplicate","page":"SmallCollections.jl","title":"SmallCollections.duplicate","text":"duplicate(v::V, i::Integer, x) where V <: AbstractSmallVector{T} -> V\n\nDuplicate the i-th entry of v by inserting it at position i+1 and return the new vector.\n\nSee also insert.\n\nExample\n\njulia> v = SmallVector{8,Int8}(1:3)\n3-element SmallVector{8, Int8}:\n 1\n 2\n 3\n\njulia> duplicate(v, 2)\n4-element SmallVector{8, Int8}:\n 1\n 2\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.deleteat","page":"SmallCollections.jl","title":"SmallCollections.deleteat","text":"deleteat(v::V, i::Integer) where V <: AbstractSmallVector -> V\n\nReturn the AbstractSmallVector obtained from v by deleting the element at position i. The latter must be between 1 and length(v).\n\nSee also Base.deleteat!, BangBang.deleteat!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.popat","page":"SmallCollections.jl","title":"SmallCollections.popat","text":"popat(v::V, i::Integer) where {T, V <: AbstractSmallVector{T}} -> Tuple{V,T}\n\nReturn the tuple (w, x) where w obtained from v by deleting the element x at position i. The latter must be between 1 and length(v).\n\nSee also Base.popat!, BangBang.popat!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.append","page":"SmallCollections.jl","title":"SmallCollections.append","text":"append(v::V, ws...) where V <: AbstractSmallVector -> V\n\nAppend all elements of the collections ws to v and return the new vector. Note that the resulting AbstractSmallVector has the same capacity as v.\n\nSee also Base.append!, BangBang.append!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.prepend","page":"SmallCollections.jl","title":"SmallCollections.prepend","text":"prepend(v::V, ws...) where V <: AbstractSmallVector -> V\n\nPrepend all elements of the collections ws to v and return the new vector. Note that the resulting AbstractSmallVector has the same capacity as v.\n\nSee also Base.prepend!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.support","page":"SmallCollections.jl","title":"SmallCollections.support","text":"support(v::AbstractSmallVector) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the non-zero elements of v.\n\nSee also SmallBitSet.\n\nExample\n\njulia> v = SmallVector{8,Int8}([1, 0, 2, 0, 0, 3]);\n\njulia> support(v)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  3\n  6\n\n\n\n\n\n","category":"function"},{"location":"#sec-smallvector","page":"SmallCollections.jl","title":"SmallVector","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallVector\nempty(::SmallVector)\nfasthash(::SmallVector, ::UInt)\nsum_fast\nmap","category":"page"},{"location":"#SmallCollections.SmallVector","page":"SmallCollections.jl","title":"SmallCollections.SmallVector","text":"SmallVector{N,T} <: AbstractSmallVector{T}\n\nSmallVector{N,T}()\nSmallVector{N,T}(iter)\nSmallVector{N}(v::AbstractVector{T})\nSmallVector{N}(t::Tuple)\nSmallVector(v::PackedVector{T})\n\nSmallVector{N,T} is an immutable vector type that can hold up to N elements of type T. Here N can be any (small) positive integer. However, at least for bit integer and hardware float types, one usually takes N to be a power of 2.\n\nThe element type T can be omitted when creating the SmallVector from an AbstractVector or from a tuple. In the latter case, T is determined by promoting the element types of the tuple. If no argument is given, then an empty vector is returned. If the SmallVector is created from a PackedVector v and the parameter N is omitted, then it is set to capacity of v.\n\nThe unused elements of a SmallVector{N,T} are filled with the value default(T), which is predefined for several types including Number. Default values for other types must be defined explicitly.\n\nAddition and subtraction of two SmallVectors is possible even if the vectors have different capacity. (Of course, their lengths must agree.) The capacity of the result is the smaller of the arguments' capacities in this case.\n\nSee also capacity, SmallCollections.default, promote_type.\n\nExamples\n\njulia> v = SmallVector{8,Int8}(2*x for x in 1:3)\n3-element SmallVector{8, Int8}:\n 2\n 4\n 6\n\njulia> w = SmallVector{9}((1, 2.5, 4))\n3-element SmallVector{9, Float64}:\n 1.0\n 2.5\n 4.0\n\njulia> v+w\n3-element SmallVector{8, Float64}:\n  3.0\n  6.5\n 10.0\n\n\n\n\n\n","category":"type"},{"location":"#Base.empty-Tuple{SmallVector}","page":"SmallCollections.jl","title":"Base.empty","text":"empty(v::V) where V <: SmallVector -> V\nempty(v::SmallVector{N}, U::Type) where {N,U} -> SmallVector{N,U}\n\nCalled with one argument, return an empty SmallVector of the same type as v. Called with two arguments, return an empty SmallVector with the same capacity as v and element type U.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.fasthash-Tuple{SmallVector, UInt64}","page":"SmallCollections.jl","title":"SmallCollections.fasthash","text":"fasthash(v::SmallVector [, h0::UInt]) -> UInt\n\nReturn a hash for v that may be computed faster than the standard hash for vectors. This new hash is consistent across all SmallVectorss of the same element type, but it may not be compatible with hash or with fasthash for a SmallVector having a different element type.\n\nCurrently, fasthash differs from hash only if the element type of v is a bit integer type with at most 32 bits, Bool or Char.\n\nSee also Base.hash.\n\nExamples\n\njulia> v = SmallVector{8,Int8}([1, 5, 6]);\n\njulia> fasthash(v)\n0x6466067ab41d0916\n\njulia> fasthash(v) == hash(v)\nfalse\n\njulia> w = SmallVector{16,Int8}(v); fasthash(v) == fasthash(w)\ntrue\n\njulia> w = SmallVector{8,Int16}(v); fasthash(v) == fasthash(w)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.sum_fast","page":"SmallCollections.jl","title":"SmallCollections.sum_fast","text":"sum_fast(v::SmallVector{N,T}) where {N,T}\n\nReturn the sum of the elements of v using @fastmath arithmetic if T is Float32 or Float64. Otherwise return sum(v).\n\nSee also Base.@fastmath.\n\nExample\n\njulia> v = SmallVector{4}([-0.0, -0.0])\n2-element SmallVector{4, Float64}:\n -0.0\n -0.0\n\njulia> sum(v), sum_fast(v)\n(-0.0, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"#Base.map","page":"SmallCollections.jl","title":"Base.map","text":"map(f, v::SmallVector...) -> SmallVector\n\nApply f to the argument vectors elementwise and stop when one of them is exhausted. Note that the capacity of the resulting SmallVector is the minimum of the argument vectors' capacities.\n\nSee also capacity, Base.map(f, v::AbstractVector...), Section \"Broadcasting\".\n\nExamples\n\njulia> v = SmallVector{8}(1:3); w = SmallVector{4}(2.0:4.0); map(*, v, w)\n3-element SmallVector{4, Float64}:\n  2.0\n  6.0\n 12.0\n\njulia> v = SmallVector{8}('a':'e'); w = SmallVector{4}('x':'z'); map(*, v, w)\n3-element SmallVector{4, String}:\n \"ax\"\n \"by\"\n \"cz\"\n\n\n\n\n\n","category":"function"},{"location":"#sec-packedvector","page":"SmallCollections.jl","title":"PackedVector","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"PackedVector\nbits(::PackedVector)\nSmallCollections.unsafe_add\nSmallCollections.unsafe_sub","category":"page"},{"location":"#SmallCollections.PackedVector","page":"SmallCollections.jl","title":"SmallCollections.PackedVector","text":"PackedVector{U<:Unsigned,M,T<:Union{Base.BitInteger,Bool}} <: AbstractSmallVector{T}\n\nPackedVector{U,M,T}()\nPackedVector{U,M,T}(iter)\nPackedVector{U,M}(v::AbstractVector{T})\nPackedVector{U,M}(t::Tuple)\nPackedVector(v::SmallVector{M,T})\n\nThis type of immutable vector stores the elements in a common bit mask of type U with M bits for each entry. The range of allowed values is -2^(M-1):2^(M-1)-1 if T <: Signed, 0:2^M-1 if T <: Unsigned and false:true if T == Bool. Apart from that, the official element type T is only used when retrieving an entry.  The capacity, that is, the number of elements that can be stored, is given by bitsize(U)Ã·M.\n\nThe element type T can be omitted when creating the PackedVector from an AbstractVector or from a tuple. In the latter case, T is determined by promoting the element types of the tuple. If no argument is given, then an empty vector is returned. If the PackedVector is created from a SmallVector v and the parameters U and M are omitted, then M is set to bitsize(T) and U is chosen such that the capacity of the resulting vector is at least the capacity of v.\n\nOverflow or underflow during addition or subtraction of vectors do not throw an error. The same applies to multiplication by a scalar of type T. Scalar multiplication by other types returns a Vector.\n\nCompared to a SmallVector, a PackedVector may have faster insert and delete operations. Arithmetic operations are usually slower unless M is the size of a hardware integer.\n\nSee also capacity, SmallCollections.bitsize.\n\nExamples\n\njulia> v = PackedVector{UInt64,5,Int8}(-5:5:10)\n4-element PackedVector{UInt64, 5, Int8}:\n -5\n  0\n  5\n 10\n\njulia> capacity(v)\n12\n\njulia> w = PackedVector{UInt64,5,Int8}([1, 2, 3, 4])\n4-element PackedVector{UInt64, 5, Int8}:\n 1\n 2\n 3\n 4\n\njulia> v+w\n4-element PackedVector{UInt64, 5, Int8}:\n -4\n  2\n  8\n 14\n\njulia> Int8(2)*v\n4-element PackedVector{UInt64, 5, Int8}:\n -10\n   0\n  10\n -12\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.bits-Tuple{PackedVector}","page":"SmallCollections.jl","title":"SmallCollections.bits","text":"bits(v::PackedVector{U}) where U -> U\n\nReturn the bit mask used internally to store the elements of the vector v.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.unsafe_add","page":"SmallCollections.jl","title":"SmallCollections.unsafe_add","text":"SmallCollections.unsafe_add(v::V, w::V) where V <: PackedVector -> V\n\nAdd v and w and return the result. It is not checked that v and w have the same length. No overflow or underflow is allowed in any component, nor are sign changes in the case of signed integers.\n\nThis function is much faster than regular addition.\n\nSee also unsafe_sub.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.unsafe_sub","page":"SmallCollections.jl","title":"SmallCollections.unsafe_sub","text":"SmallCollections.unsafe_sub(v::V, w::V) where V <: PackedVector -> V\n\nSubtract w from v and return the result. It is not checked that v and w have the same length. No overflow or underflow  is allowed in any component, nor are sign changes in the case of signed integers.\n\nThis function is much faster than regular addition.\n\nSee also unsafe_add.\n\n\n\n\n\n","category":"function"},{"location":"#sec-broadcasting","page":"SmallCollections.jl","title":"Broadcasting","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"Broadcasting is supported for SmallVector. The result is again a SmallVector if at least one argument is a SmallVector and all other arguments (if any) are Tuples or scalars. The capacity of the result is the minimum of the capacities of the SmallVector arguments. Broadcasted assignments to a SmallVector are of course not possible.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"See also map, capacity, SmallCollections.SmallVectorStyle.","category":"page"},{"location":"#Examples","page":"SmallCollections.jl","title":"Examples","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"julia> v = SmallVector{8}(1:3); w = SmallVector{6}(2:4); v .* w .- 1.0\n3-element SmallVector{6, Float64}:\n  1.0\n  5.0\n 11.0\n\njulia> v = SmallVector{8}(1:3); w = [2, 3, 4]; v .* w\n3-element Vector{Int64}:\n  2\n  6\n 12\n\njulia> v = SmallVector{8}('a':'c'); t = ('p', 'q', 'r'); uppercase.(v .* t .* 'x')\n3-element SmallVector{8, String}:\n \"APX\"\n \"BQX\"\n \"CRX\"","category":"page"},{"location":"#sec-smallbitset","page":"SmallCollections.jl","title":"SmallBitSet","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallBitSet\nbits(::SmallBitSet)\nconvert(::Type{SmallBitSet}, ::Integer)\ncapacity(::Type{<:SmallBitSet})\nfasthash(::SmallBitSet, ::UInt)\nempty(::SmallBitSet)\npush(::SmallBitSet, ::Vararg)\npop(::SmallBitSet)\npop(::SmallBitSet, ::Any)\npop(::SmallBitSet, ::Any, ::Any)\ndelete","category":"page"},{"location":"#SmallCollections.SmallBitSet","page":"SmallCollections.jl","title":"SmallCollections.SmallBitSet","text":"SmallBitSet{U<:Unsigned} <: AbstractSet{Int}\n\nSmallBitSet{U}([iter])\nSmallBitSet([iter])\n\nSmallBitSet{U} is an immutable set that can hold integers between 1 and the bit length of U. Called without an argument, it returns an empty set. If U is omitted, then UInt is taken.\n\nAll non-mutating functions for sets are supported. The non-mutating analogs push, pop and delete of the corresponding !-functions are also provided.\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.bits-Tuple{SmallBitSet}","page":"SmallCollections.jl","title":"SmallCollections.bits","text":"bits(s::SmallBitSet{U}) where U -> U\n\nReturn the bit mask used internally to store the elements of the set s.\n\nSee also convert(::Type{SmallBitSet}, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"#Base.convert-Tuple{Type{SmallBitSet}, Integer}","page":"SmallCollections.jl","title":"Base.convert","text":"convert(::Type{SmallBitSet{U}}, mask::Integer) where U -> SmallBitSet{U}\nconvert(::Type{SmallBitSet}, mask::Integer) -> SmallBitSet{UInt}\n\nConvert a bit mask to a SmallBitSet of the given type. This is the inverse operation to bits.\n\nSee also bits.\n\nExamples\n\njulia> s = SmallBitSet{UInt16}([1, 5, 6]);\n\njulia> u = bits(s)\n0x0031\n\njulia> convert(SmallBitSet, u)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  5\n  6\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.capacity-Tuple{Type{<:SmallBitSet}}","page":"SmallCollections.jl","title":"SmallCollections.capacity","text":"capacity(::Type{<:SmallBitSet}) -> Int\ncapacity(s::SmallBitSet) -> Int\n\nReturn the largest number that the given set or SmallBitSet type can store.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.fasthash-Tuple{SmallBitSet, UInt64}","page":"SmallCollections.jl","title":"SmallCollections.fasthash","text":"fasthash(s::SmallBitSet [, h0::UInt]) -> UInt\n\nReturn a hash for s that can be computed fast. This hash is consistent across all SmallBitSets, but it is not compatible with the hash used for sets.\n\nSee also Base.hash.\n\nExamples\n\njulia> s = SmallBitSet(1:3);\n\njulia> fasthash(s)\n0x828a4cc485149963\n\njulia> fasthash(s) == hash(s)\nfalse\n\njulia> t = SmallBitSet{UInt16}(s);\n\njulia> fasthash(s) == fasthash(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty-Tuple{SmallBitSet}","page":"SmallCollections.jl","title":"Base.empty","text":"empty(s::S) where S <: SmallBitSet -> S\n\nReturn an empty SmallBitSet of the same type as s.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.push-Tuple{SmallBitSet, Vararg}","page":"SmallCollections.jl","title":"SmallCollections.push","text":"push(s::S, xs...) where S <: SmallBitSet -> S\n\nReturn the SmallBitSet obtained from s by adding the other arguments xs.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where x is the smallest element from s and t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet, Any}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S, x) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet, Any, Any}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S, x, default::T) where S <: SmallBitSet -> Tuple{S, Union{Int,T}}\n\nIf s contains x, return the pair (t, x) where t is the set s with x deleted. Otherwise return (s, default)\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.delete","page":"SmallCollections.jl","title":"SmallCollections.delete","text":"delete(s::S, x) where S <: SmallBitSet -> S\n\nIf s contains x, return the set obtained by deleting that element. Otherwise return s.\n\nSee also Base.delete!, BangBang.delete!!.\n\n\n\n\n\n","category":"function"},{"location":"#Subsets-and-shuffles","page":"SmallCollections.jl","title":"Subsets and shuffles","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"When used with a SmallBitSet as first argument, the following functions internally use the function pdep. As discussed in the docstring for pdep, performance is much better if the processor supports the BMI2 instruction set. The same applies to shuffles with more than two parts, even if the first argument is not a SmallBitSet.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"subsets(::Integer)\nsubsets(::Integer, ::Integer)\ncompositions\nshuffles(::Vararg{Integer})\nshuffle_signbit","category":"page"},{"location":"#SmallCollections.subsets-Tuple{Integer}","page":"SmallCollections.jl","title":"SmallCollections.subsets","text":"subsets(s::S) where S <: SmallBitSet -> AbstractVector{S}\nsubsets(n::Integer) -> AbstractVector{SmallBitSet{UInt}}\n\nIn the first form, return a vector of length 2^length(s) whose elements are the subsets of the set s.\n\nIn the second form the set s is taken to be SmallBitSet(1:n).\n\nSee also subsets(::Integer, ::Integer).\n\nExamples\n\njulia> collect(subsets(SmallBitSet{UInt8}([3, 5])))\n4-element Vector{SmallBitSet{UInt8}}:\n SmallBitSet([])\n SmallBitSet([3])\n SmallBitSet([5])\n SmallBitSet([3, 5])\n\njulia> collect(subsets(2))\n4-element Vector{SmallBitSet{UInt64}}:\n SmallBitSet([])\n SmallBitSet([1])\n SmallBitSet([2])\n SmallBitSet([1, 2])\n\njulia> subsets(2)[2]\nSmallBitSet{UInt64} with 1 element:\n  1\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.subsets-Tuple{Integer, Integer}","page":"SmallCollections.jl","title":"SmallCollections.subsets","text":"subsets(s::SmallBitSet, k::Integer)\nsubsets(n::Integer, k::Integer)\n\nIn the first form, return an iterator that yields all k-element subsets of the set s. The element type is the type of s. If k is negative or larger than length(s), then the iterator is empty.\n\nIn the second form the set s is taken to be SmallBitSet(1:n).\n\nSee also subsets(::Integer), shuffles.\n\nExample\n\njulia> collect(subsets(SmallBitSet{UInt8}(2:2:8), 3))\n4-element Vector{SmallBitSet{UInt8}}:\n SmallBitSet([2, 4, 6])\n SmallBitSet([2, 4, 8])\n SmallBitSet([2, 6, 8])\n SmallBitSet([4, 6, 8])\n\njulia> collect(subsets(3, 2))\n3-element Vector{SmallBitSet{UInt64}}:\n SmallBitSet([1, 2])\n SmallBitSet([1, 3])\n SmallBitSet([2, 3])\n\njulia> collect(subsets(3, 4))\nSmallBitSet{UInt64}[]\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.compositions","page":"SmallCollections.jl","title":"SmallCollections.compositions","text":"compositions(s::S, ks::Vararg{Integer,N}) where {S <: SmallBitSet, N}\ncompositions(ks::Vararg{Integer,N}) where N\n\nIn the first form, return an iterator that yields all ks-compositions of the set s, that is, all ordered partitions of s into N sets of size ks[1] to ks[N], respectively. The element type is NTuple{N, S}. The partition sizes in ks must be non-negative and add up to length(s).\n\nIn the second form the set s is taken to be SmallBitSet(1:sum(ks)). This gives an iterator over all set compositions of the integer sum(ks).\n\nSee also subsets, shuffles.\n\nExamples\n\njulia> collect(compositions(SmallBitSet([2, 4, 5]), 1, 2))\n3-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([2]), SmallBitSet([4, 5]))\n (SmallBitSet([4]), SmallBitSet([2, 5]))\n (SmallBitSet([5]), SmallBitSet([2, 4]))\n\njulia> collect(compositions(1, 1, 1))\n6-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([1]), SmallBitSet([2]), SmallBitSet([3]))\n (SmallBitSet([2]), SmallBitSet([1]), SmallBitSet([3]))\n (SmallBitSet([1]), SmallBitSet([3]), SmallBitSet([2]))\n (SmallBitSet([3]), SmallBitSet([1]), SmallBitSet([2]))\n (SmallBitSet([2]), SmallBitSet([3]), SmallBitSet([1]))\n (SmallBitSet([3]), SmallBitSet([2]), SmallBitSet([1]))\n\njulia> collect(compositions(SmallBitSet([2, 4, 5]), 1, 0, 2))\n3-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([2]), SmallBitSet([]), SmallBitSet([4, 5]))\n (SmallBitSet([4]), SmallBitSet([]), SmallBitSet([2, 5]))\n (SmallBitSet([5]), SmallBitSet([]), SmallBitSet([2, 4]))\n\njulia> collect(compositions(SmallBitSet()))\n1-element Vector{Tuple{}}:\n ()\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.shuffles-Tuple{Vararg{Integer}}","page":"SmallCollections.jl","title":"SmallCollections.shuffles","text":"shuffles(s::S, ks::Vararg{Integer,N}) where {S <: SmallBitSet, N}\nshuffles(ks::Vararg{Integer,N}) where N\n\nIn the first form, return an iterator that yields all ks-compositions of the set s together with the sign of the permutation that puts the elements back into an increasing order. See compositions and shuffle_signbit for details. The iterator returns tuples (t, s), where t is of type NTuple{N, S} and the sign bit s is of type Bool where false means +1 and true means -1. The partition sizes in ks must be non-negative and add up to length(s).\n\nIn the second form the set s is taken to be SmallBitSet(1:sum(ks)).\n\nSee also compositions, shuffle_signbit.\n\nExamples\n\njulia> collect(shuffles(SmallBitSet([2, 4, 5]), 1, 2))\n3-element Vector{Tuple{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}}, Bool}}:\n ((SmallBitSet([2]), SmallBitSet([4, 5])), 0)\n ((SmallBitSet([4]), SmallBitSet([2, 5])), 1)\n ((SmallBitSet([5]), SmallBitSet([2, 4])), 0)\n\njulia> all(s == shuffle_signbit(a, b) for ((a, b), s) in shuffles(1, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.shuffle_signbit","page":"SmallCollections.jl","title":"SmallCollections.shuffle_signbit","text":"shuffle_signbit(ss::SmallBitSet...) -> Bool\n\nReturn true if an odd number of transpositions is needed to transform the elements of the sets ss into an increasing sequence, and false otherwise. The sets are considered as increasing sequences and assumed to be disjoint.\n\nSee also shuffles.\n\nExamples\n\njulia> s, t, u = SmallBitSet([2, 3, 8]), SmallBitSet([1, 4, 6]), SmallBitSet([5, 7]);\n\njulia> shuffle_signbit(s, t), shuffle_signbit(s, t, u)\n(true, false)\n\n\n\n\n\n","category":"function"},{"location":"#sec-bangbang","page":"SmallCollections.jl","title":"BangBang support","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"If the package BangBang.jl is loaded, then the functions push, pop, delete, union, intersect, setdiff and symdiff for SmallBitSet as well as setindex, push, pushfirst,  pop, popfirst, deleteat and append for AbstractSmallVector are also available in !!-form. For example, setindex!! with an AbstractSmallVector as first argument calls setindex. (BangBang.jl does not define insert!!, prepend!!, filter!! and map!!.) Moreover, add!!(v::AbstractSmallVector, w::AbstractSmallVector) is a synonym for v+w.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"This allows to write efficient code that works for both mutable and immutable arguments. For example, the function","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"f!!(v, ws...) = foldl(add!!, ws; init = v)","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"adds up its arguments, mutating the first argument v if possible.","category":"page"},{"location":"#Non-exported-names","page":"SmallCollections.jl","title":"Non-exported names","text":"","category":"section"},{"location":"#Public-names","page":"SmallCollections.jl","title":"Public names","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections.bitsize\nSmallCollections.default\nSmallCollections.SmallVectorStyle","category":"page"},{"location":"#SmallCollections.bitsize","page":"SmallCollections.jl","title":"SmallCollections.bitsize","text":"SmallCollections.bitsize(T::Type) -> Int\nSmallCollections.bitsize(x::T) where T -> Int\n\nReturn the size of the internal binary representation of T in bits. For Bool the function returns 1.\n\nSee also Base.sizeof.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.default","page":"SmallCollections.jl","title":"SmallCollections.default","text":"SmallCollections.default(::Type{T}) where T -> T\nSmallCollections.default(::T) where T -> T\n\nReturn the default value of type T used for filling unused elements of a SmallVector. This must be defined as zero(T) if T supports algebraic operations. Otherwise it can be any value of type T.\n\nThis function has methods for number types, bits types (including Char, SmallVector and SmallBitSet types), String and Symbol. Methods for other types must be defined explicitly.\n\nSee also Base.isbitstype.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.SmallVectorStyle","page":"SmallCollections.jl","title":"SmallCollections.SmallVectorStyle","text":"SmallCollections.SmallVectorStyle <: Broadcast.AbstractArrayStyle{1}\n\nThe broadcasting style used for SmallVector.\n\nSee also SmallVector, Broadcast.AbstractArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"#Internal-names","page":"SmallCollections.jl","title":"Internal names","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"These names are not public and may change in future versions.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections.AbstractBitInteger\nSmallCollections.top_set_bit\nSmallCollections.unsafe_shl\nSmallCollections.unsafe_lshr\nSmallCollections.pdep","category":"page"},{"location":"#SmallCollections.AbstractBitInteger","page":"SmallCollections.jl","title":"SmallCollections.AbstractBitInteger","text":"SmallCollections.AbstractBitInteger\n\nThis type is the union of Base.BitInteger, BitIntegers.AbstractBitSigned and BitIntegers.AbstractBitUnsigned.\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.top_set_bit","page":"SmallCollections.jl","title":"SmallCollections.top_set_bit","text":"SmallCollections.top_set_bit(x::AbstractBitInteger) -> Int\n\nReturn the position of the highest set bit in x (counting from 1), or return 0 if x is 0.\n\nThis function is analogous to Julia's internal function Base.top_set_bit, but it is also fast and correct for bit integers defined by BitIntegers.jl.\n\nSee also Base.top_set_bit, SmallCollections.AbstractBitInteger.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.unsafe_shl","page":"SmallCollections.jl","title":"SmallCollections.unsafe_shl","text":"SmallCollections.unsafe_shl(x::U, i::Integer) where U <: AbstractBitInteger -> U\n\nThis is a fast, but unsafe version of the left bit shift operator x << i. The shift i is assumed to be between 0 and bitsize(x)-1.\n\nSee also SmallCollections.bitsize, SmallCollections.AbstractBitInteger.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.unsafe_lshr","page":"SmallCollections.jl","title":"SmallCollections.unsafe_lshr","text":"SmallCollections.unsafe_lshr(x::U, i::Integer) where U <: AbstractBitInteger -> U\n\nThis is a fast, but unsafe version of the logical (or unsigned) right bit shift operator x >>> i. The shift i is assumed to be between 0 and bitsize(x)-1.\n\nSee also SmallCollections.bitsize, SmallCollections.AbstractBitInteger.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.pdep","page":"SmallCollections.jl","title":"SmallCollections.pdep","text":"SmallCollections.pdep(x::Unsigned, y::U) where U <: Unsigned -> U\n\nAssume that y has exactly m 1-bits. Then pdep(x, y) replaces these bits by the m lowest bits of x (in order) and returns the result. The remaining bits of x are ignored.\n\nOn x86_64 and i686 machines, this function uses the corresponding instruction from the BMI2 instruction set if possible. Without hardware support it is much slower.\n\n\n\n\n\n","category":"function"}]
}
