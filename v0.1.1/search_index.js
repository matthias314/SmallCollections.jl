var documenterSearchIndex = {"docs":
[{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"DocTestSetup = quote\n        using SmallCollections\n    # for jldoctest outside of docstrings\n    end","category":"page"},{"location":"#SmallCollections.jl","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections","category":"page"},{"location":"#SmallCollections","page":"SmallCollections.jl","title":"SmallCollections","text":"SmallCollections\n\nThis packages provides several immutable collections that don't allocate and are therefore faster than the usual types. The number of elements that these collections can hold is necessarily limited. At present SmallBitSet and SmallVector are defined.\n\nIf the package BangBang.jl is loaded, then many functions defined by this package are also available in !!-form. For example, setindex!! with a SmallVector as first argument calls setindex.\n\nSee SmallBitSet, SmallVector, Section \"BangBang support\".\n\n\n\n\n\n","category":"module"},{"location":"#sec-smallvector","page":"SmallCollections.jl","title":"SmallVector","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallVector\ncapacity(::Type{<:SmallVector{N}}) where N\nfasthash(::SmallVector, ::UInt)\nempty(::SmallVector)\nzeros\nones\nsetindex\npush(::SmallVector, ::Vararg)\npop(::SmallVector)\npushfirst\npopfirst\ninsert\ndeleteat\npopat\nappend\nprepend\nsum_fast\nmap\nsupport","category":"page"},{"location":"#SmallCollections.SmallVector","page":"SmallCollections.jl","title":"SmallCollections.SmallVector","text":"SmallVector{N,T} <: AbstractVector{T}\n\nSmallVector{N,T}()\nSmallVector{N,T}(iter)\nSmallVector{N}(v::AbstractVector{T})\nSmallVector{N}(t::Tuple)\n\nSmallVector{N,T} is an immutable vector type that can hold up to N elements of type T. Here N can be any (small) positive integer. However, at least for bit integer and hardware float types, one usually takes N to be a power of 2.\n\nThe element type T can be omitted when creating the SmallVector from an AbstractVector or from a tuple. In the latter case, T is determined by promoting the element types of the tuple. If no argument is given, then an empty vector is returned.\n\nThe unused elements of a SmallVector{N,T} are filled with the value default(T), which is predefined for several types including Number. Default values for other types must be defined explicitly.\n\nAddition and subtraction of two SmallVectors is possible even if the vectors have different capacity. (Of course, their lengths must agree.) The capacity of the result is the smaller of the arguments' capacities in this case.\n\nSee also capacity, SmallCollections.default, promote_type.\n\nExamples\n\njulia> v = SmallVector{8,Int8}(2*x for x in 1:3)\n3-element SmallVector{8, Int8}:\n 2\n 4\n 6\n\njulia> w = SmallVector{9}((1, 2.5, 4))\n3-element SmallVector{9, Float64}:\n 1.0\n 2.5\n 4.0\n\njulia> v+w\n3-element SmallVector{8, Float64}:\n  3.0\n  6.5\n 10.0\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.capacity-Union{Tuple{Type{<:SmallVector{N}}}, Tuple{N}} where N","page":"SmallCollections.jl","title":"SmallCollections.capacity","text":"capacity(::Type{<:SmallVector{N}}) where N -> N\ncapacity(v::SmallVector{N}) where N -> N\n\nReturn N, which is the largest number of elements this vector type can hold.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.fasthash-Tuple{SmallVector, UInt64}","page":"SmallCollections.jl","title":"SmallCollections.fasthash","text":"fasthash(v::SmallVector [, h0::UInt]) -> UInt\n\nReturn a hash for v that may be computed faster than the standard hash for vectors. This new hash is consistent across all SmallVectorss of the same element type, but it may not be compatible with hash or with fasthash for a SmallVector having a different element type.\n\nCurrently, fasthash differs from hash only if the element type of v is a bit integer type with at most 32 bits, Bool or Char.\n\nSee also Base.hash.\n\nExamples\n\njulia> v = SmallVector{8,Int8}([1, 5, 6]);\n\njulia> fasthash(v)\n0x6466067ab41d0916\n\njulia> fasthash(v) == hash(v)\nfalse\n\njulia> w = SmallVector{16,Int8}(v); fasthash(v) == fasthash(w)\ntrue\n\njulia> w = SmallVector{8,Int16}(v); fasthash(v) == fasthash(w)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty-Tuple{SmallVector}","page":"SmallCollections.jl","title":"Base.empty","text":"empty(v::V) where V <: SmallVector -> V\nempty(v::SmallVector{N}, U::Type) where {N,U} -> SmallVector{N,U}\n\nCalled with one argument, return an empty SmallVector of the same type as v. Called with two arguments, return an empty SmallVector with the same capacity as v and element type U.\n\n\n\n\n\n","category":"method"},{"location":"#Base.zeros","page":"SmallCollections.jl","title":"Base.zeros","text":"zeros(::Type{V}, n::Integer) where V <: SmallVector -> V\n\nReturn a SmallVector of type V containing n zeros.\n\nSee also ones.\n\n\n\n\n\n","category":"function"},{"location":"#Base.ones","page":"SmallCollections.jl","title":"Base.ones","text":"ones(::Type{V}, n::Integer) where V <: SmallVector -> V\n\nReturn a SmallVector of type V containing n ones.\n\nSee also zeros.\n\n\n\n\n\n","category":"function"},{"location":"#Base.setindex","page":"SmallCollections.jl","title":"Base.setindex","text":"setindex(v::V, x, i::Integer) where V <: SmallVector -> V\n\nReturn a vector that agrees with v except possibly for the i-th entry that is set to x.\n\nSee also Base.setindex.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.push-Tuple{SmallVector, Vararg}","page":"SmallCollections.jl","title":"SmallCollections.push","text":"push(v::SmallVector{N,T}, xs...) where {N,T} -> SmallVector{N,T}\n\nReturn the SmallVector obtained from v by appending the other arguments xs. The length of v must be less than N.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallVector}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(v::SmallVector{N,T}) where {N,T} -> Tuple{SmallVector{N,T},T}\n\nReturn the tuple (w, x) where x is the last element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pushfirst","page":"SmallCollections.jl","title":"SmallCollections.pushfirst","text":"pushfirst(v::SmallVector{N,T}, xs...) where {N,T} -> SmallVector{N,T}\n\nReturn the SmallVector obtained from v by prepending the other arguments xs. The length of v must be less than N.\n\nSee also Base.pushfirst!, BangBang.pushfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.popfirst","page":"SmallCollections.jl","title":"SmallCollections.popfirst","text":"popfirst(v::SmallVector{N,T}) where {N,T} -> Tuple{SmallVector{N,T},T}\n\nReturn the tuple (w, x) where x is the first element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.popfirst!, BangBang.popfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.insert","page":"SmallCollections.jl","title":"SmallCollections.insert","text":"insert(v::SmallVector{N,T}, i::Integer, x) where {N,T} -> SmallVector{N,T}\n\nReturn the SmallVector obtained from v by inserting x at position i. The position i must be between 1 and length(v)+1, and length(v) must be less than N.\n\nThis is the non-mutating analog of Base.insert!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.deleteat","page":"SmallCollections.jl","title":"SmallCollections.deleteat","text":"deleteat(v::V, i::Integer) where V <: SmallVector -> V\n\nReturn the SmallVector obtained from v by deleting the element at position i. The position i must be between 1 and length(v).\n\nSee also Base.deleteat!, BangBang.deleteat!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.popat","page":"SmallCollections.jl","title":"SmallCollections.popat","text":"popat(v::SmallVector{N,T}, i::Integer) where {N,T} -> Tuple{SmallVector{N,T},T}\n\nReturn the tuple (w, x) where w obtained from v by deleting the element x at position i. The latter must be between 1 and length(v).\n\nSee also Base.popat!, BangBang.popat!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.append","page":"SmallCollections.jl","title":"SmallCollections.append","text":"append(v::V, ws...) where V <: SmallVector -> V\n\nAppend all elements of the collections ws to v and return the new vector. Note that the resulting SmallVector has the same capacity as v.\n\nSee also Base.append!, BangBang.append!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.prepend","page":"SmallCollections.jl","title":"SmallCollections.prepend","text":"prepend(v::V, ws...) where V <: SmallVector -> V\n\nPrepend all elements of the collections ws to v and return the new vector. Note that the resulting SmallVector has the same capacity as v.\n\nSee also Base.prepend!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.sum_fast","page":"SmallCollections.jl","title":"SmallCollections.sum_fast","text":"sum_fast(v::SmallVector{N,T}) where {N,T}\n\nReturn the sum of the elements of v using @fastmath arithmetic if T is Float32 or Float64. Otherwise return sum(v).\n\nSee also Base.@fastmath.\n\nExample\n\njulia> v = SmallVector{4}([-0.0, -0.0])\n2-element SmallVector{4, Float64}:\n -0.0\n -0.0\n\njulia> sum(v), sum_fast(v)\n(-0.0, 0.0)\n\n\n\n\n\n","category":"function"},{"location":"#Base.map","page":"SmallCollections.jl","title":"Base.map","text":"map(f, v::SmallVector...) -> SmallVector\n\nApply f to the argument vectors elementwise and stop when one of them is exhausted. Note that the capacity of the resulting SmallVector is the minimum of the argument vectors' capacities.\n\nSee also capacity, Base.map(f, v::AbstractVector...), Section \"Broadcasting\".\n\nExamples\n\njulia> v = SmallVector{8}(1:3); w = SmallVector{4}(2.0:4.0); map(*, v, w)\n3-element SmallVector{4, Float64}:\n  2.0\n  6.0\n 12.0\n\njulia> v = SmallVector{8}('a':'e'); w = SmallVector{4}('x':'z'); map(*, v, w)\n3-element SmallVector{4, String}:\n \"ax\"\n \"by\"\n \"cz\"\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.support","page":"SmallCollections.jl","title":"SmallCollections.support","text":"support(v::SmallVector) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the non-zero elements of v.\n\nSee also SmallBitSet.\n\nExample\n\njulia> v = SmallVector{8,Int8}([1, 0, 2, 0, 0, 3]);\n\njulia> support(v)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  3\n  6\n\n\n\n\n\n","category":"function"},{"location":"#sec-broadcasting","page":"SmallCollections.jl","title":"Broadcasting","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"Broadcasting is supported for SmallVector. The result is again a SmallVector if at least one argument is a SmallVector and all other arguments (if any) are Tuples or scalars. The capacity of the result is the minimum of the capacities of the SmallVector arguments. Broadcasted assignments to a SmallVector are of course not possible.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"See also map, capacity, SmallCollections.SmallVectorStyle.","category":"page"},{"location":"#Examples","page":"SmallCollections.jl","title":"Examples","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"julia> v = SmallVector{8}(1:3); w = SmallVector{6}(2:4); v .* w .- 1.0\n3-element SmallVector{6, Float64}:\n  1.0\n  5.0\n 11.0\n\njulia> v = SmallVector{8}(1:3); w = [2, 3, 4]; v .* w\n3-element Vector{Int64}:\n  2\n  6\n 12\n\njulia> v = SmallVector{8}('a':'c'); t = ('p', 'q', 'r'); uppercase.(v .* t .* 'x')\n3-element SmallVector{8, String}:\n \"APX\"\n \"BQX\"\n \"CRX\"","category":"page"},{"location":"#sec-smallbitset","page":"SmallCollections.jl","title":"SmallBitSet","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallBitSet\nbits\nconvert(::Type{SmallBitSet}, ::Integer)\ncapacity(::Type{<:SmallBitSet})\nfasthash(::SmallBitSet, ::UInt)\nempty(::SmallBitSet)\npush(::SmallBitSet, ::Vararg)\npop(::SmallBitSet)\npop(::SmallBitSet, ::Any)\npop(::SmallBitSet, ::Any, ::Any)\ndelete","category":"page"},{"location":"#SmallCollections.SmallBitSet","page":"SmallCollections.jl","title":"SmallCollections.SmallBitSet","text":"SmallBitSet{U<:Unsigned} <: AbstractSet{Int}\n\nSmallBitSet{U}([iter])\nSmallBitSet([iter])\n\nSmallBitSet{U} is an immutable set that can hold integers between 1 and the bit length of U. Called without an argument, it returns an empty set. If U is omitted, then UInt is taken.\n\nAll non-mutating functions for sets are supported. The non-mutating analogs push, pop and delete of the corresponding !-functions are also provided.\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.bits","page":"SmallCollections.jl","title":"SmallCollections.bits","text":"bits(s::SmallBitSet{U}) where U -> U\n\nReturn the bit mask used internally to store the elements of the set s.\n\nSee also convert(::Type{SmallBitSet}, ::Integer).\n\n\n\n\n\n","category":"function"},{"location":"#Base.convert-Tuple{Type{SmallBitSet}, Integer}","page":"SmallCollections.jl","title":"Base.convert","text":"convert(::Type{SmallBitSet{U}}, mask::Integer) where U -> SmallBitSet{U}\nconvert(::Type{SmallBitSet}, mask::Integer) -> SmallBitSet{UInt}\n\nConvert a bit mask to a SmallBitSet of the given type. This is the inverse operation to bits.\n\nSee also bits.\n\nExamples\n\njulia> s = SmallBitSet{UInt16}([1, 5, 6]);\n\njulia> u = bits(s)\n0x0031\n\njulia> convert(SmallBitSet, u)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  5\n  6\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.capacity-Tuple{Type{<:SmallBitSet}}","page":"SmallCollections.jl","title":"SmallCollections.capacity","text":"capacity(::Type{<:SmallBitSet}) -> Int\ncapacity(s::SmallBitSet) -> Int\n\nReturn the largest number that the given set or SmallBitSet type can store.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.fasthash-Tuple{SmallBitSet, UInt64}","page":"SmallCollections.jl","title":"SmallCollections.fasthash","text":"fasthash(s::SmallBitSet [, h0::UInt]) -> UInt\n\nReturn a hash for s that can be computed fast. This hash is consistent across all SmallBitSets, but it is not compatible with the hash used for sets.\n\nSee also Base.hash.\n\nExamples\n\njulia> s = SmallBitSet(1:3);\n\njulia> fasthash(s)\n0x828a4cc485149963\n\njulia> fasthash(s) == hash(s)\nfalse\n\njulia> t = SmallBitSet{UInt16}(s);\n\njulia> fasthash(s) == fasthash(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty-Tuple{SmallBitSet}","page":"SmallCollections.jl","title":"Base.empty","text":"empty(s::S) where S <: SmallBitSet -> S\n\nReturn an empty SmallBitSet of the same type as s.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.push-Tuple{SmallBitSet, Vararg}","page":"SmallCollections.jl","title":"SmallCollections.push","text":"push(s::S, xs...) where S <: SmallBitSet -> S\n\nReturn the SmallBitSet obtained from s by adding the other arguments xs.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where x is the smallest element from s and t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet, Any}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S, x) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet, Any, Any}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S, x, default::T) where S <: SmallBitSet -> Tuple{S, Union{Int,T}}\n\nIf s contains x, return the pair (t, x) where t is the set s with x deleted. Otherwise return (s, default)\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.delete","page":"SmallCollections.jl","title":"SmallCollections.delete","text":"delete(s::S, x) where S <: SmallBitSet -> S\n\nIf s contains x, return the set obtained by deleting that element. Otherwise return s.\n\nSee also Base.delete!, BangBang.delete!!.\n\n\n\n\n\n","category":"function"},{"location":"#sec-bangbang","page":"SmallCollections.jl","title":"BangBang support","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"If the package BangBang.jl is loaded, then the functions push, pop, delete, union, intersect, setdiff and symdiff for SmallBitSet as well as setindex, push, pushfirst,  pop, popfirst, deleteat and append for SmallVector are also available in !!-form. For example, setindex!! with a SmallVector as first argument calls setindex. (BangBang.jl does not define insert!!, prepend!! and map!!.) Moreover, add!!(v::SmallVector, w::SmallVector) is a synonym for v+w.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"This allows to write efficient code that works for both mutable and immutable arguments. For example, the function","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"f!!(v, ws...) = foldl(add!!, ws; init = v)","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"adds up its arguments, mutating the first argument v if possible.","category":"page"},{"location":"#Non-exported-functions","page":"SmallCollections.jl","title":"Non-exported functions","text":"","category":"section"},{"location":"#Public-functions","page":"SmallCollections.jl","title":"Public functions","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections.default\nSmallCollections.SmallVectorStyle","category":"page"},{"location":"#SmallCollections.default","page":"SmallCollections.jl","title":"SmallCollections.default","text":"SmallCollections.default(::Type{T}) where T -> T\nSmallCollections.default(::T) where T -> T\n\nReturn the default value of type T used for filling unused elements of a SmallVector. This must be defined as zero(T) if T supports algebraic operations. Otherwise it can be any value of type T.\n\nThis function has methods for number types, bits types (including Char, SmallVector and SmallBitSet types), String and Symbol. Methods for other types must be defined explicitly.\n\nSee also Base.isbitstype.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.SmallVectorStyle","page":"SmallCollections.jl","title":"SmallCollections.SmallVectorStyle","text":"SmallCollections.SmallVectorStyle <: Broadcast.AbstractArrayStyle{1}\n\nThe broadcasting style used for SmallVector.\n\nSee also Broadcast.AbstractArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"#Internal-functions","page":"SmallCollections.jl","title":"Internal functions","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections.bitsize\nSmallCollections.top_set_bit","category":"page"},{"location":"#SmallCollections.bitsize","page":"SmallCollections.jl","title":"SmallCollections.bitsize","text":"SmallCollections.bitsize(T::Type) -> Int\n\nReturn the size of the internal binary representation of T in bits.\n\nSee also Base.sizeof.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.top_set_bit","page":"SmallCollections.jl","title":"SmallCollections.top_set_bit","text":"SmallCollections.top_set_bit(x::Unsigned) -> Int\n\nReturn the position of the highest set bit in x (counting from 1), or return 0 if x is 0.\n\nThis function is analogous to Julia's internal function Base.top_set_bit, but it is also fast and correct for bit integers defined by BitIntegers.jl.\n\nSee also Base.top_set_bit.\n\n\n\n\n\n","category":"function"}]
}
