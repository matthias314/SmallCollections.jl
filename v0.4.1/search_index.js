var documenterSearchIndex = {"docs":
[{"location":"broadcast/#sec-broadcasting","page":"Broadcasting","title":"Broadcasting","text":"","category":"section"},{"location":"broadcast/","page":"Broadcasting","title":"Broadcasting","text":"All vector types defined by this package can participate in broadcasting. Efficient implementations exist for AbstractFixedVector and AbstractSmallVector, including broadcasted assignments to a MutableFixedVector or MutableSmallVector. Without assignment, the result is a FixedVector (or SmallVector) if at least one argument is an AbstractFixedVector (or AbstractSmallVector) and all other arguments (if any) are Tuples or scalars. Otherwise Julia's generic broadcasting method applies. The capacity of a resulting SmallVector is the minimum of the capacities of the AbstractSmallVector arguments.","category":"page"},{"location":"broadcast/","page":"Broadcasting","title":"Broadcasting","text":"See also map, capacity, SmallCollections.FixedVectorStyle, SmallCollections.SmallVectorStyle.","category":"page"},{"location":"broadcast/#Examples","page":"Broadcasting","title":"Examples","text":"","category":"section"},{"location":"broadcast/","page":"Broadcasting","title":"Broadcasting","text":"julia> v = MutableSmallVector{8}(1:3); w = SmallVector{6}(2:4); v .* w .- 1.0\n3-element SmallVector{6, Float64}:\n  1.0\n  5.0\n 11.0\n\njulia> v .+= 3 .* w\n3-element MutableSmallVector{8, Int64}:\n  7\n 11\n 15\n\njulia> v = FixedVector{3}(1:3); w = [2, 3, 4]; v .* w\n3-element Vector{Int64}:\n  2\n  6\n 12\n\njulia> v = SmallVector{8}('a':'c'); t = ('p', 'q', 'r'); uppercase.(v .* t .* 'x')\n3-element SmallVector{8, String}:\n \"APX\"\n \"BQX\"\n \"CRX\"","category":"page"},{"location":"nonexported/#Non-exported-names","page":"Non-exported names","title":"Non-exported names","text":"","category":"section"},{"location":"nonexported/#Public-names","page":"Non-exported names","title":"Public names","text":"","category":"section"},{"location":"nonexported/#Functionality-for-small-and-fixed-vectors","page":"Non-exported names","title":"Functionality for small and fixed vectors","text":"","category":"section"},{"location":"nonexported/#SmallCollections.default","page":"Non-exported names","title":"SmallCollections.default","text":"SmallCollections.default(::Type{T}) where T -> T\nSmallCollections.default(::T) where T -> T\n\nReturn the default value of type T used for filling unused elements of an AbstractSmallVector. This must be defined as zero(T) if T supports algebraic operations. Otherwise it can be any value of type T.\n\nThis function has methods for number types, bits types, Symbol, AbstractChar, AbstractString, Tuple, NamedTuple, AbstractFixedVector, AbstractSmallVector und SmallBitSet. Methods for other types must be defined explicitly, see the examples below.\n\nSee also Base.isbitstype.\n\nExamples\n\nWe start by defining a default value for an immutable struct.\n\njulia> import SmallCollections: default\n\njulia> struct A x::Int end\n\njulia> default(::Type{A}) = A(0);\n\nFor a mutable struct one needs to create an object first.\n\njulia> mutable struct B x::Int end\n\njulia> const b0 = B(0);\n\njulia> default(::Type{B}) = b0;\n\nFor mutable parametric types one can use a generated function.\n\njulia> mutable struct C{T} x::T end\n\njulia> @generated default(::Type{C{T}}) where T = C(default(T));\n\njulia> default(C{Bool})\nC{Bool}(false)\n\njulia> default(C{Bool}) === default(C{Bool})  # do we always get the same object?\ntrue\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.isfasttype","page":"Non-exported names","title":"SmallCollections.isfasttype","text":"SmallCollections.isfasttype(::Type{T}) where T -> Bool\n\nReturn true if elements of type T permit fast (for instance, vectorized) operations.\n\nBy default, Base.HWReal, Bool, Char, and Enum types are considered fast, as well as Complex, Pair, Tuple, NamedTuple and Ref with fast components.\n\nSee Base.HWReal.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.MapStyle","page":"Non-exported names","title":"SmallCollections.MapStyle","text":"SmallCollections.MapStyle\n\nMapStyle(f, types::Type...) -> MapStyle\n\nA MapStyle determines how SmallCollections evaluates certain functions like map or findfirst that take a function f as argument. The available subtypes of MapStyle are as follows, from the least to the most efficient:\n\nLazyStyle: the function f is only evaluated when strictly necessary, and it is not assumed to be defined for default values. This is the default MapStyle for unknown functions.\nEagerStyle: f may be evaluated more often than strictly necessary, and it is assumed to be defined for default values. However, it need not map default values to default values.\nRigidStyle: f may be evaluated more often than strictly necessary. It is assumed to be defined for default values and to return a default value if all arguments are default values.\nStrictStyle: f may be evaluated more often than strictly necessary. It is assumed to be defined for default values and to return a default value if at least one argument is a default value. (This is the same as RigidStyle for functions with a single argument.)\n\nThe MapStyle is predefined for many functions from Base as well as for operations that produce new functions out of old. Unnamed functions are not recognized. However, several functions from SmallCollections allow to specify a MapStyle as keyword argument. In addition, users can define a MapStyle for their own types.\n\nSee also SmallCollections.default, SmallCollections.isfasttype.\n\nExamples\n\njulia> using SmallCollections: MapStyle\n\njulia> MapStyle(iszero, Int)   # not RigidStyle: iszero(0) is true, not false\nSmallCollections.EagerStyle()\n\njulia> MapStyle(+, Int, Int)\nSmallCollections.RigidStyle()\n\njulia> MapStyle(*, Int, Float64)   # not StrictStyle: 0 * Inf is NaN, not 0.0\nSmallCollections.RigidStyle()\n\njulia> MapStyle(*, Int, Int)\nSmallCollections.StrictStyle()\n\njulia> MapStyle(-, Int)\nSmallCollections.StrictStyle()\n\njulia> MapStyle(x -> -x, Int)   # not StrictStyle: anonymous function not recognized\nSmallCollections.LazyStyle()\n\njulia> MapStyle(-, Int128)   # Int128 is not a fast type, so better be lazy\nSmallCollections.LazyStyle()\n\njulia> MapStyle(isfiniteâˆ˜inv, Float64)   # function composition is recognized\nSmallCollections.EagerStyle()\n\njulia> MapStyle(!isodd, Int)  # function composition again\nSmallCollections.EagerStyle()\n\njulia> MapStyle(!iszero, Int)   # separately defined to override EagerStyle\nSmallCollections.StrictStyle()\n\njulia> MapStyle(>=(1), Int)   # >=(1) is Base.Fix2(>=, 1), which is recognized\nSmallCollections.EagerStyle()\n\n\n\n\n\n","category":"type"},{"location":"nonexported/#SmallCollections.FixedVectorStyle","page":"Non-exported names","title":"SmallCollections.FixedVectorStyle","text":"SmallCollections.FixedVectorStyle <: Broadcast.AbstractArrayStyle{1}\n\nThe broadcasting style used for AbstractFixedVector.\n\nSee also AbstractFixedVector, Broadcast.AbstractArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"nonexported/#SmallCollections.SmallVectorStyle","page":"Non-exported names","title":"SmallCollections.SmallVectorStyle","text":"SmallCollections.SmallVectorStyle <: Broadcast.AbstractArrayStyle{1}\n\nThe broadcasting style used for AbstractSmallVector.\n\nSee also AbstractSmallVector, Broadcast.AbstractArrayStyle.\n\n\n\n\n\n","category":"type"},{"location":"nonexported/#SmallCollections.padtail","page":"Non-exported names","title":"SmallCollections.padtail","text":"SmallCollections.padtail(v::AbstractFixedVector{N,T}, i::Integer, x = default(T)) where {N,T} -> FixedVector{N,T}\n\nReplace the elements of v after the i-th position by x and return the new vector. Providing an out-of-bounds index i does not produce an error.\n\nExample\n\njulia> v = FixedVector{4,Int}(1:4);\n\njulia> SmallCollections.padtail(v, 2)\n4-element FixedVector{4, Int64}:\n 1\n 2\n 0\n 0\n\njulia> SmallCollections.padtail(v, 2, -1)\n4-element FixedVector{4, Int64}:\n  1\n  2\n -1\n -1\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#Bit-operations","page":"Non-exported names","title":"Bit operations","text":"","category":"section"},{"location":"nonexported/#SmallCollections.bitsize","page":"Non-exported names","title":"SmallCollections.bitsize","text":"SmallCollections.bitsize(T::Type) -> Int\nSmallCollections.bitsize(x::T) where T -> Int\n\nReturn the size of the internal binary representation of T in bits. For Bool the function returns 1.\n\nSee also Base.sizeof.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.unsafe_shl","page":"Non-exported names","title":"SmallCollections.unsafe_shl","text":"SmallCollections.unsafe_shl(x::U, i::Integer) where U <: AbstractBitInteger -> U\n\nThis is a fast, but unsafe version of the left bit shift operator x << i. The shift i is assumed to be between 0 and bitsize(x)-1.\n\nSee also SmallCollections.bitsize, SmallCollections.AbstractBitInteger.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.unsafe_lshr","page":"Non-exported names","title":"SmallCollections.unsafe_lshr","text":"SmallCollections.unsafe_lshr(x::U, i::Integer) where U <: AbstractBitInteger -> U\n\nThis is a fast, but unsafe version of the logical (or unsigned) right bit shift operator x >>> i. The shift i is assumed to be between 0 and bitsize(x)-1.\n\nSee also SmallCollections.bitsize, SmallCollections.AbstractBitInteger.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.blsi","page":"Non-exported names","title":"SmallCollections.blsi","text":"SmallCollections.blsi(x::T) where T <: Integer -> T\n\nExtract the lowest set bit of x. For hardware integers, this compiles to a single BLSI instruction from the BMI1 instruction set on x86_64 and i686 machines.\n\nSee also SmallCollections.blsr, SmallCollections.blsmsk.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.blsr","page":"Non-exported names","title":"SmallCollections.blsr","text":"SmallCollections.blsr(x::T) where T <: Integer -> T\n\nReset the lowest set bit of x. For hardware integers, this compiles to a single BLSR instruction from the BMI1 instruction set on x86_64 and i686 machines.\n\nSee also SmallCollections.blsi, SmallCollections.blsmsk.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.blsmsk","page":"Non-exported names","title":"SmallCollections.blsmsk","text":"SmallCollections.blsmsk(x::T) where T <: Integer -> T\n\nGet the bit mask up to lowest set bit of x. For hardware integers, this compiles to a single BLSMSK instruction from the BMI1 instruction set on x86_64 and i686 machines.\n\nSee also SmallCollections.blsi, SmallCollections.blsr.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.pdep","page":"Non-exported names","title":"SmallCollections.pdep","text":"SmallCollections.pdep(x::Unsigned, y::U) where U <: Unsigned -> U\n\nAssume that y has exactly m 1-bits. Then pdep(x, y) replaces these bits by the m lowest bits of x (in order) and returns the result. The remaining bits of x are ignored.\n\nOn x86_64 and i686 machines, this function uses the corresponding instruction from the BMI2 instruction set if possible. Without hardware support it is much slower.\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#Internal-names","page":"Non-exported names","title":"Internal names","text":"","category":"section"},{"location":"nonexported/","page":"Non-exported names","title":"Non-exported names","text":"These names are not public and may change in future versions.","category":"page"},{"location":"nonexported/#SmallCollections.element_type","page":"Non-exported names","title":"SmallCollections.element_type","text":"SmallCollections.element_type(itr) -> Type\nSmallCollections.element_type(::Type) -> Type\n\nReturn the element type of an iterator or its type. This differs from eltype in that the element type of a Tuple or NamedTuple is determined via promote_type instead of promote_typejoin. For all other iterators there is no difference.\n\nSee also Base.eltype, Base.promote_type, Base.promote_typejoin.\n\nExample\n\njulia> eltype((1, 2, 3.0))\nReal\n\njulia> SmallCollections.element_type((1, 2, 3.0))\nFloat64\n\n\n\n\n\n","category":"function"},{"location":"nonexported/#SmallCollections.AbstractBitInteger","page":"Non-exported names","title":"SmallCollections.AbstractBitInteger","text":"SmallCollections.AbstractBitInteger\n\nThis type is the union of Base.BitInteger, BitIntegers.AbstractBitSigned and BitIntegers.AbstractBitUnsigned.\n\n\n\n\n\n","category":"type"},{"location":"nonexported/#SmallCollections.top_set_bit","page":"Non-exported names","title":"SmallCollections.top_set_bit","text":"SmallCollections.top_set_bit(x::AbstractBitInteger) -> Int\n\nReturn the position of the highest set bit in x (counting from 1), or return 0 if x is 0.\n\nThis function is analogous to Julia's internal function Base.top_set_bit, but it is also fast and correct for bit integers defined by BitIntegers.jl.\n\nSee also Base.top_set_bit, SmallCollections.AbstractBitInteger.\n\n\n\n\n\n","category":"function"},{"location":"bangbang/#sec-bangbang","page":"BangBang support","title":"BangBang support","text":"","category":"section"},{"location":"bangbang/","page":"BangBang support","title":"BangBang support","text":"If the package BangBang.jl is loaded, then the functions push, pop and delete for SmallDict, SmallSet and SmallBitSet, union, intersect, setdiff and symdiff for SmallSet and SmallBitSet as well as setindex, push, pushfirst,  pop, popfirst, deleteat and append for AbstractCapacityVector are also available in !!-form. For example, setindex!! with an AbstractCapacityVector as first argument calls setindex. (BangBang.jl does not define insert!!, prepend!!, filter!! and map!!.) Moreover, add!!(v::AbstractCapacityVector, w::AbstractCapacityVector) is a synonym for v+w.","category":"page"},{"location":"bangbang/","page":"BangBang support","title":"BangBang support","text":"This allows to write efficient code that works for both mutable and immutable arguments. For example, the function","category":"page"},{"location":"bangbang/","page":"BangBang support","title":"BangBang support","text":"f!!(v, ws...) = foldl(add!!, ws; init = v)","category":"page"},{"location":"bangbang/","page":"BangBang support","title":"BangBang support","text":"adds up its arguments, mutating the first argument v if possible.","category":"page"},{"location":"combinatorics/#combinatorics","page":"Combinatorics","title":"Combinatorics","text":"","category":"section"},{"location":"combinatorics/#SmallCollections.Combinatorics","page":"Combinatorics","title":"SmallCollections.Combinatorics","text":"SmallCollections.Combinatorics\n\nThis module contains functions related to enumerative combinatorics.\n\n\n\n\n\n","category":"module"},{"location":"combinatorics/#Partitions","page":"Combinatorics","title":"Partitions","text":"","category":"section"},{"location":"combinatorics/#SmallCollections.Combinatorics.partitions","page":"Combinatorics","title":"SmallCollections.Combinatorics.partitions","text":"partitions(n::Integer)\n\nReturn an iterator over the partitions of n. A partition of n is a weakly decreasing sequence of positive integers that add up to n. Each partition is of type SmallVector{64,Int8}, but this may change in the future.\n\nSee also partitions(::Integer, ::Integer).\n\nExamples\n\njulia> partitions(3) |> collect\n3-element Vector{SmallVector{64, Int8}}:\n [3]\n [2, 1]\n [1, 1, 1]\n\njulia> partitions(0) |> collect\n1-element Vector{SmallVector{64, Int8}}:\n 0-element SmallVector{64, Int8}\n\n\n\n\n\npartitions(n::Integer, k::Integer)\n\nReturn an iterator over the partitions of n into k parts. A partition of n is a weakly decreasing sequence of positive integers that add up to n. Each partition is of type SmallVector{64,Int8}, but this may change in the future.\n\nSee also partitions(::Integer).\n\nExamples\n\njulia> partitions(7, 3) |> collect\n4-element Vector{SmallVector{64, Int8}}:\n [5, 1, 1]\n [4, 2, 1]\n [3, 3, 1]\n [3, 2, 2]\n\njulia> partitions(7, 0) |> collect\nSmallVector{64, Int8}[]\n\njulia> partitions(0, 0) |> collect\n1-element Vector{SmallVector{64, Int8}}:\n 0-element SmallVector{64, Int8}\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#Compositions","page":"Combinatorics","title":"Compositions","text":"","category":"section"},{"location":"combinatorics/#SmallCollections.Combinatorics.compositions","page":"Combinatorics","title":"SmallCollections.Combinatorics.compositions","text":"compositions(n::Integer, k::Integer)\n\nReturn an iterator over the compositions of n of length k. A composition of n of length k is a k-tuple of positive integers that add up to n. Each composition is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also weakcompositions, compositions_cumsum.\n\nExamples\n\njulia> compositions(3, 2) |> collect\n2-element Vector{SmallVector{16, Int8}}:\n [1, 2]\n [2, 1]\n\njulia> compositions(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> compositions(0, 0)  |> collect\n1-element Vector{SmallVector{16, Int8}}:\n 0-element SmallVector{16, Int8}\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#SmallCollections.Combinatorics.compositions_cumsum","page":"Combinatorics","title":"SmallCollections.Combinatorics.compositions_cumsum","text":"compositions_cumsum(n::Integer, k::Integer)\n\nReturn an iterator over the cumulative sums of the compositions of n of length k. A composition of n of length k is a k-tuple of positive integers that add up to n. The cumulative sum of such a composition is a vector with k+1 elements, starting with 0 and ending with n. Each vector is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also compositions, weakcompositions_cumsum.\n\nExamples\n\njulia> compositions_cumsum(3, 2) |> collect\n2-element Vector{SmallVector{16, Int8}}:\n [0, 1, 3]\n [0, 2, 3]\n\njulia> compositions_cumsum(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> compositions_cumsum(0, 0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n [0]\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#SmallCollections.Combinatorics.weakcompositions","page":"Combinatorics","title":"SmallCollections.Combinatorics.weakcompositions","text":"weakcompositions(n::Integer, k::Integer)\n\nReturn an iterator over the weak compositions of n of length k. A weak composition of n of length k is a k-tuple of non-negative integers that add up to n. Each composition is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also compositions, weakcompositions_cumsum.\n\nExamples\n\njulia> weakcompositions(3, 2) |> collect\n4-element Vector{SmallVector{16, Int8}}:\n [0, 3]\n [1, 2]\n [2, 1]\n [3, 0]\n\njulia> weakcompositions(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> weakcompositions(0, 0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n 0-element SmallVector{16, Int8}\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#SmallCollections.Combinatorics.weakcompositions_cumsum","page":"Combinatorics","title":"SmallCollections.Combinatorics.weakcompositions_cumsum","text":"weakcompositions_cumsum(n::Integer, k::Integer)\n\nReturn an iterator over the cumulative sums of the weak compositions of n of length k. A weak composition of n of length k is a k-tuple of non-negative integers that add up to n. The cumulative sum of such a composition is a vector with k+1 elements, starting with 0 and ending with n. Each vector is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also weakcompositions, compositions_cumsum.\n\nExamples\n\njulia> weakcompositions_cumsum(3, 2) |> collect\n4-element Vector{SmallVector{16, Int8}}:\n [0, 0, 3]\n [0, 1, 3]\n [0, 2, 3]\n [0, 3, 3]\n\njulia> weakcompositions_cumsum(3, 0) |> collect\nSmallVector{16, Int8}[]\n\njulia> weakcompositions_cumsum(0, 0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n [0]\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#Subsets-and-set-compositions","page":"Combinatorics","title":"Subsets and set compositions","text":"","category":"section"},{"location":"combinatorics/","page":"Combinatorics","title":"Combinatorics","text":"When used with a SmallBitSet as first argument, the following functions internally use the function pdep. As discussed in the docstring for pdep, performance is much better if the processor supports the BMI2 instruction set. The same applies to setcompositions with more than two parts, even if the first argument is not a SmallBitSet.","category":"page"},{"location":"combinatorics/#SmallCollections.Combinatorics.subsets-Tuple{Integer}","page":"Combinatorics","title":"SmallCollections.Combinatorics.subsets","text":"subsets(s::S) where S <: SmallBitSet -> AbstractVector{S}\nsubsets(n::Integer) -> AbstractVector{SmallBitSet{UInt}}\n\nIn the first form, return a vector of length 2^length(s) whose elements are the subsets of the set s.\n\nIn the second form the set s is taken to be SmallBitSet(1:n).\n\nSee also subsets(::Integer, ::Integer).\n\nExamples\n\njulia> subsets(SmallBitSet{UInt8}([3, 5])) |> collect\n4-element Vector{SmallBitSet{UInt8}}:\n SmallBitSet([])\n SmallBitSet([3])\n SmallBitSet([5])\n SmallBitSet([3, 5])\n\njulia> subsets(2) |> collect\n4-element Vector{SmallBitSet{UInt64}}:\n SmallBitSet([])\n SmallBitSet([1])\n SmallBitSet([2])\n SmallBitSet([1, 2])\n\njulia> subsets(2)[2]\nSmallBitSet{UInt64} with 1 element:\n  1\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/#SmallCollections.Combinatorics.subsets-Tuple{Integer, Integer}","page":"Combinatorics","title":"SmallCollections.Combinatorics.subsets","text":"subsets(s::SmallBitSet, k::Integer)\nsubsets(n::Integer, k::Integer)\n\nIn the first form, return an iterator that yields all k-element subsets of the set s. The element type is the type of s. If k is negative or larger than length(s), then the iterator is empty.\n\nIn the second form the set s is taken to be SmallBitSet(1:n).\n\nSee also subsets(::Integer), setcompositions_parity.\n\nExample\n\njulia> subsets(SmallBitSet{UInt8}(2:2:8), 3) |> collect\n4-element Vector{SmallBitSet{UInt8}}:\n SmallBitSet([2, 4, 6])\n SmallBitSet([2, 4, 8])\n SmallBitSet([2, 6, 8])\n SmallBitSet([4, 6, 8])\n\njulia> subsets(3, 2) |> collect\n3-element Vector{SmallBitSet{UInt64}}:\n SmallBitSet([1, 2])\n SmallBitSet([1, 3])\n SmallBitSet([2, 3])\n\njulia> subsets(3, 4) |> collect\nSmallBitSet{UInt64}[]\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/#SmallCollections.Combinatorics.setcompositions","page":"Combinatorics","title":"SmallCollections.Combinatorics.setcompositions","text":"setcompositions(s::S, ks::Vararg{Integer,N}) where {S <: SmallBitSet, N}\nsetcompositions(ks::Vararg{Integer,N}) where N\n\nIn the first form, return an iterator that yields all ks-compositions of the set s, that is, all ordered partitions of s into N sets of size ks[1] to ks[N], respectively. The element type is NTuple{N, S}. The partition sizes in ks must be non-negative and add up to length(s).\n\nIn the second form the set s is taken to be SmallBitSet(1:sum(ks)). This gives an iterator over all set compositions of the integer sum(ks).\n\nSee also subsets, setcompositions_parity.\n\nExamples\n\njulia> setcompositions(SmallBitSet([2, 4, 5]), 1, 2) |> collect\n3-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([2]), SmallBitSet([4, 5]))\n (SmallBitSet([4]), SmallBitSet([2, 5]))\n (SmallBitSet([5]), SmallBitSet([2, 4]))\n\njulia> setcompositions(1, 1, 1) |> collect\n6-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([1]), SmallBitSet([2]), SmallBitSet([3]))\n (SmallBitSet([2]), SmallBitSet([1]), SmallBitSet([3]))\n (SmallBitSet([1]), SmallBitSet([3]), SmallBitSet([2]))\n (SmallBitSet([3]), SmallBitSet([1]), SmallBitSet([2]))\n (SmallBitSet([2]), SmallBitSet([3]), SmallBitSet([1]))\n (SmallBitSet([3]), SmallBitSet([2]), SmallBitSet([1]))\n\njulia> setcompositions(SmallBitSet([2, 4, 5]), 1, 0, 2) |> collect\n3-element Vector{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}, SmallBitSet{UInt64}}}:\n (SmallBitSet([2]), SmallBitSet([]), SmallBitSet([4, 5]))\n (SmallBitSet([4]), SmallBitSet([]), SmallBitSet([2, 5]))\n (SmallBitSet([5]), SmallBitSet([]), SmallBitSet([2, 4]))\n\njulia> setcompositions(SmallBitSet()) |> collect\n1-element Vector{Tuple{}}:\n ()\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#SmallCollections.Combinatorics.setcompositions_parity-Tuple{Vararg{Integer}}","page":"Combinatorics","title":"SmallCollections.Combinatorics.setcompositions_parity","text":"setcompositions_parity(s::S, ks::Vararg{Integer,N}) where {S <: SmallBitSet, N}\nsetcompositions_parity(ks::Vararg{Integer,N}) where N\n\nIn the first form, return an iterator that yields all ks-compositions of the set s together with the parity of the permutation that puts the elements back into an increasing order. See setcompositions and setcomposition_parity for details. The iterator returns tuples (t, p), where t is of type NTuple{N, S} and the parity p is of type Bool where false means even and true means odd. The partition sizes in ks must be non-negative and add up to length(s).\n\nIn the second form the set s is taken to be SmallBitSet(1:sum(ks)).\n\nSee also setcompositions, setcomposition_parity.\n\nExamples\n\njulia> setcompositions_parity(SmallBitSet([2, 4, 5]), 1, 2) |> collect\n3-element Vector{Tuple{Tuple{SmallBitSet{UInt64}, SmallBitSet{UInt64}}, Bool}}:\n ((SmallBitSet([2]), SmallBitSet([4, 5])), 0)\n ((SmallBitSet([4]), SmallBitSet([2, 5])), 1)\n ((SmallBitSet([5]), SmallBitSet([2, 4])), 0)\n\njulia> all(s == setcomposition_parity(a, b) for ((a, b), s) in setcompositions_parity(1, 2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"combinatorics/#SmallCollections.Combinatorics.setcomposition_parity","page":"Combinatorics","title":"SmallCollections.Combinatorics.setcomposition_parity","text":"setcomposition_parity(ss::SmallBitSet...) -> Bool\n\nReturn true if an odd number of transpositions is needed to transform the elements of the sets ss into an increasing sequence, and false otherwise. The sets are considered as increasing sequences and assumed to be disjoint.\n\nSee also setcompositions_parity.\n\nExamples\n\njulia> s, t, u = SmallBitSet([2, 3, 8]), SmallBitSet([1, 4, 6]), SmallBitSet([5, 7]);\n\njulia> setcomposition_parity(s, t), setcomposition_parity(s, t, u)\n(true, false)\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#Permutations","page":"Combinatorics","title":"Permutations","text":"","category":"section"},{"location":"combinatorics/#SmallCollections.Combinatorics.permutations","page":"Combinatorics","title":"SmallCollections.Combinatorics.permutations","text":"permutations(n::Integer)\n\nReturn an iterator that yields all permutations of the integers from 1 to n.\n\nThe argument n must be between 0 and 16. The identity permutation is returned first. Each permutation is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also permutations_parity_transposition.\n\nExamples\n\njulia> permutations(3) |> collect\n6-element Vector{SmallVector{16, Int8}}:\n [1, 2, 3]\n [2, 1, 3]\n [3, 1, 2]\n [1, 3, 2]\n [2, 3, 1]\n [3, 2, 1]\n\njulia> permutations(0) |> collect\n1-element Vector{SmallVector{16, Int8}}:\n 0-element SmallVector{16, Int8}\n\n\n\n\n\n","category":"function"},{"location":"combinatorics/#SmallCollections.Combinatorics.permutations_parity_transposition","page":"Combinatorics","title":"SmallCollections.Combinatorics.permutations_parity_transposition","text":"permutations_parity_transposition(n::Integer)\n\nReturn an iterator that yields all permutations p of the integers from 1 to n together with some extra data. The first element of the tuple returned is the permutation p. The second element is the parity of p (false for even and true for odd permutations). The third element is a pair (i, j) that indicates the transposition t by which p differs from the previously returned permutation q. (More precisely, the new permutations p is obtained by first applying t and then q.)\n\nThe argument n must be between 0 and 16. The iterator returns the identity permutation first; in this case the transposition pair is set to (0, 0). The true transpositions (i, j) satisfy i < j. Each permutation is of type SmallVector{16,Int8}, but this may change in the future.\n\nSee also permutations.\n\nExamples\n\njulia> permutations_parity_transposition(3) |> collect\n6-element Vector{Tuple{SmallVector{16, Int8}, Int64, Tuple{Int64, Int64}}}:\n ([1, 2, 3], 0, (0, 0))\n ([2, 1, 3], 1, (1, 2))\n ([3, 1, 2], 0, (1, 3))\n ([1, 3, 2], 1, (1, 2))\n ([2, 3, 1], 0, (1, 3))\n ([3, 2, 1], 1, (1, 2))\n\njulia> permutations_parity_transposition(0) |> collect\n1-element Vector{Tuple{SmallVector{16, Int8}, Int64, Tuple{Int64, Int64}}}:\n ([], 0, (0, 0))\n\n\n\n\n\n","category":"function"},{"location":"smalldict/#sec-abstractsmalldict","page":"Small dictionaries","title":"Small dictionaries","text":"","category":"section"},{"location":"smalldict/#SmallCollections.AbstractSmallDict","page":"Small dictionaries","title":"SmallCollections.AbstractSmallDict","text":"AbstractSmallDict{N,K,V} <: AbstractDict{K,V}\n\nThis is the supertype of SmallDict{N,K,V} and MutableSmallDict{N,K,V}.\n\nSee also SmallDict, MutableSmallDict.\n\n\n\n\n\n","category":"type"},{"location":"smalldict/#SmallCollections.SmallDict","page":"Small dictionaries","title":"SmallCollections.SmallDict","text":"SmallDict{N,K,V} <: AbstractSmallDict{N,K,V}\n\nSmallDict{N,K,V}()\nSmallDict{N,K,V}(itr; unique = itr isa AbstractDict)\nSmallDict{N,K,V}(key1 => val1, key2 => val2, ...; unique = false)\n\nAn immutable dictionary with key type K and value type V that can store up to N entries. All entries come from the key-value iterator itr provided at construction time or from the explicitly given pairs.\n\nIf the key and value types are omitted, they will be inferred from the pairs or, if possible, from the iterator. If unique is set to true, then the elements of itr are assumed to have distinct keys.\n\nSee also AbstractSmallDict, MutableSmallDict.\n\nExamples\n\njulia> SmallDict{8}(Int16(1) => 2, Int32(3) => 4.0)\nSmallDict{8, Int32, Float64} with 2 entries:\n  1 => 2.0\n  3 => 4.0\n\njulia> SmallDict{8,Char,Int}('a'+k => k^2 for k in 0:2; unique = true)\nSmallDict{8, Char, Int64} with 3 entries:\n  'a' => 0\n  'b' => 1\n  'c' => 4\n\n\n\n\n\n","category":"type"},{"location":"smalldict/#SmallCollections.MutableSmallDict","page":"Small dictionaries","title":"SmallCollections.MutableSmallDict","text":"MutableSmallDict{N,K,V} <: AbstractSmallDict{N,K,V}\n\nMutableSmallDict{N,K,V}()\nMutableSmallDict{N,K,V}(itr; unique = itr isa AbstractDict)\nMutableSmallDict{N,K,V}(key1 => val1, key2 => val2, ...; unique = false)\n\nAn dictionary with key type K and value type V that can store up to N entries. The dictionary is mutable and implements Julia's dictionary interface.\n\nIf the key and value types are omitted, they will be inferred from the pairs or, if possible, from the iterator. If unique is set to true, then the elements of itr are assumed to have distinct keys.\n\nSee also AbstractSmallDict, SmallDict.\n\nExamples\n\njulia> d = MutableSmallDict{8}('a' => 0, 'b' => 1, 'c' => 4)\nMutableSmallDict{8, Char, Int64} with 3 entries:\n  'a' => 0\n  'b' => 1\n  'c' => 4\n\n\njulia> delete!(d, 'b')\nMutableSmallDict{8, Char, Int64} with 2 entries:\n  'a' => 0\n  'c' => 4\n\n\n\n\n\n","category":"type"},{"location":"smalldict/#SmallCollections.capacity-Tuple{Type{<:AbstractSmallDict}}","page":"Small dictionaries","title":"SmallCollections.capacity","text":"capacity(::Type{<:AbstractSmallDict}) -> Int\ncapacity(d::AbstractSmallDict) -> Int\n\nReturn the largest number of elements the given dictionary type can hold.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#Base.empty-Tuple{AbstractSmallDict}","page":"Small dictionaries","title":"Base.empty","text":"empty(d::AbstractSmallDict{N,K,V}) where {N,K,V,W} -> AbstractSmallVector{N,K,V}\nempty(d::AbstractSmallDict{N,K,V}, W::Type) where {N,K,V,W} -> AbstractSmallVector{N,K,W}\nempty(d::AbstractSmallDict{N,K,V}, L::Type, W::Type) where {N,K,V,L,W} -> AbstractSmallVector{N,L,W}\n\nReturn an empty AbstractSmallDictionary with the same capacity as d, and with valtype changed to W and keytype changed to L if so specified. The resulting dictionary is mutable if and only if d is so.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#Base.setindex-Tuple{AbstractSmallDict, Any, Any}","page":"Small dictionaries","title":"Base.setindex","text":"setindex(d::AbstractSmallDict{N,K,V}, val, key) where {N,K,V} -> Tuple{SmallDict{N,K,V}, V}\n\nReturn the dictionary that is obtained from d by adding the mapping key => val.\n\nSee also Base.setindex!, push.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#SmallCollections.invget","page":"Small dictionaries","title":"SmallCollections.invget","text":"invget(d::AbstractSmallDict{N,K}, val) where {N,K} -> K\n\nReturn a key in d whose value is equal to val (in the sense of isequal). If there is no such key, an error is raised.\n\nThis reverse lookup is as fast as \"forward\" lookup by keys. The key returned is the first matching one in keys(d).\n\n\n\n\n\ninvget(d::AbstractSmallDict{N,K}, val, default::T) where {N,K,T} -> Union{K,T}\n\nReturn a key in d whose value is equal to val (in the sense of isequal). If there is no such key, return default.\n\nThis reverse lookup is as fast as \"forward\" lookup by keys. The key returned is the first matching one in keys(d).\n\n\n\n\n\n","category":"function"},{"location":"smalldict/#SmallCollections.getmin","page":"Small dictionaries","title":"SmallCollections.getmin","text":"getmin(d::AbstractSmallDict) -> Pair{<:K,<:V}\ngetmax(d::AbstractSmallDict) -> Pair{<:K,<:V}\n\nReturn a key-values pair that realizes the minimum (or maximum) among the values of the non-empty dictionary d.\n\nSee also popmin, popmin!.\n\n\n\n\n\n","category":"function"},{"location":"smalldict/#SmallCollections.push-Tuple{AbstractSmallDict, Pair}","page":"Small dictionaries","title":"SmallCollections.push","text":"push(d::AbstractSmallDict{N,K,V}, key1 => val1, key2 => val2, ...) where {N,K,V} -> Tuple{SmallDict{N,K,V}, V}\n\nReturn the dictionary that is obtained from d by adding the mappings given as arguments.\n\nSee also Base.push!, setindex.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#SmallCollections.pop-Tuple{AbstractSmallDict}","page":"Small dictionaries","title":"SmallCollections.pop","text":"pop(d::AbstractSmallDict{N,K,V}) where {N,K,V} -> Tuple{SmallDict{N,K,V}, Pair{<:K,<:V}}\n\nRemove a mapping key => val from d and return the new dictionary together with the mapping. The dictionary d must not be empty.\n\nSee also Base.pop!.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#SmallCollections.pop-Tuple{AbstractSmallDict, Any}","page":"Small dictionaries","title":"SmallCollections.pop","text":"pop(d::AbstractSmallDict{N,K,V}, key) where {N,K,V} -> Tuple{SmallDict{N,K,V}, V}\n\nRemove the mapping for key from d and return the new dictionary together with the value d[key].\n\nSee also Base.pop!, delete.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#SmallCollections.pop-Tuple{AbstractSmallDict, Any, Any}","page":"Small dictionaries","title":"SmallCollections.pop","text":"pop(d::AbstractSmallDict{N,K,V}, key, default::U) where {N,K,V,U} -> Tuple{SmallDict{N,K,V}, Union{V,U}}\n\nIf d has the key key, remove it and return the new dictionary together with d[key]. Otherwise return the tuple (SmallDict(d), default).\n\nSee also Base.pop!.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#SmallCollections.delete-Tuple{AbstractSmallDict, Any}","page":"Small dictionaries","title":"SmallCollections.delete","text":"delete(d::AbstractSmallDict{N,K,V}, key) where {N,K,V} -> SmallDict{N,K,V}\n\nRemove the mapping for key from d (if it exists) and return the new dictionary.\n\nSee also Base.delete!, pop.\n\n\n\n\n\n","category":"method"},{"location":"smalldict/#SmallCollections.popmin","page":"Small dictionaries","title":"SmallCollections.popmin","text":"popmin(d::AbstractSmallDict) -> Tuple{SmallDict{N,K,V}, Pair{<:K,<:V}}\npopmax(d::AbstractSmallDict) -> Tuple{SmallDict{N,K,V}, Pair{<:K,<:V}}\n\nFind a key-values pair that realizes the minimum (or maximum) among the values of the non-empty dictionary d. Return the pair together with a dictionary obtained from d by removing that pair.\n\nSee also getmin, popmin!.\n\n\n\n\n\n","category":"function"},{"location":"smalldict/#SmallCollections.popmin!","page":"Small dictionaries","title":"SmallCollections.popmin!","text":"popmin!(d::AbstractSmallDict) -> Pair{<:K,<:V}\npopmax!(d::AbstractSmallDict) -> Pair{<:K,<:V}\n\nFind a key-values pair that realizes the minimum (or maximum) among the values of the non-empty dictionary d. Return that pair and delete it from d.\n\nSee also getmin, popmin.\n\n\n\n\n\n","category":"function"},{"location":"smalldict/#Base.findall-Tuple{Function, AbstractSmallDict}","page":"Small dictionaries","title":"Base.findall","text":"findall(f::Function, d::AbstractSmallDict{N,K}; [style::MapStyle]) where {N,K} -> SmallVector{N,K}\n\nWith an AbstractSmallDict d as second argument, this function accepts the keyword argument style. If it equals LazyStyle(), then the function f is only evaluated on the actual values of d. For any other value of style, f is evaluated on values(d) as well as on the default values used for padding this SmallVector. This is often faster for simple functions.\n\nAs discussed under MapStyle, the default value for style is based on a list of known functions.\n\nSee also SmallCollections.default, SmallCollections.MapStyle.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#sec-abstractsmallset","page":"Small sets","title":"Small sets","text":"","category":"section"},{"location":"smallset/#SmallCollections.AbstractSmallSet","page":"Small sets","title":"SmallCollections.AbstractSmallSet","text":"AbstractSmallSet{N,T} <: AbstractSet{T}\n\nThis is the supertype of SmallSet{N,T} and MutableSmallSet{N,T}.\n\nSee also SmallSet, MutableSmallSet.\n\n\n\n\n\n","category":"type"},{"location":"smallset/#SmallCollections.SmallSet","page":"Small sets","title":"SmallCollections.SmallSet","text":"SmallSet{N,T} <: AbstractSmallSet{N,T}\n\nSmallSet{N,T}()\nSmallSet{N,T}(itr; unique = itr isa AbstractSet)\n\nAn immutable set with element type T that can store up to N entries. All entries come from the iterator itr provided at construction time.\n\nIf the element type is omitted, it will be inferred from the iterator, if possible. If unique is set to true, then the elements of itr are assumed to be distinct.\n\nSee also AbstractSmallSet, MutableSmallSet.\n\n\n\n\n\n","category":"type"},{"location":"smallset/#SmallCollections.MutableSmallSet","page":"Small sets","title":"SmallCollections.MutableSmallSet","text":"MutableSmallSet{N,T} <: AbstractSmallSet{N,T}\n\nMutableSmallSet{N,T}()\nMutableSmallSet{N,T}(itr; unique = itr isa AbstractSet)\n\nA set with element type T that can store up to N entries. The set is mutable and implements Julia's set interface.\n\nIf the element type is omitted, it will be inferred from the iterator, if possible. If unique is set to true, then the elements of itr are assumed to be distinct.\n\nSee also AbstractSmallSet, SmallSet.\n\n\n\n\n\n","category":"type"},{"location":"smallset/#SmallCollections.capacity-Tuple{Type{<:AbstractSmallSet}}","page":"Small sets","title":"SmallCollections.capacity","text":"capacity(::Type{<:AbstractSmallSet}) -> Int\ncapacity(d::AbstractSmallSet) -> Int\n\nReturn the largest number of elements the given dictionary type can hold.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#Base.empty-Tuple{AbstractSmallSet}","page":"Small sets","title":"Base.empty","text":"empty(d::AbstractSmallDict{N,K,V}) where {N,K,V,W} -> AbstractSmallVector{N,K,V}\nempty(d::AbstractSmallDict{N,K,V}, W::Type) where {N,K,V,W} -> AbstractSmallVector{N,K,W}\nempty(d::AbstractSmallDict{N,K,V}, L::Type, W::Type) where {N,K,V,L,W} -> AbstractSmallVector{N,L,W}\n\nReturn an empty AbstractSmallDictionary with the same capacity as d, and with valtype changed to W and keytype changed to L if so specified. The resulting dictionary is mutable if and only if d is so.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#Base.values-Tuple{AbstractSmallSet}","page":"Small sets","title":"Base.values","text":"values(s::AbstractSmallSet{N,T}) where {N,T} -> SmallVector{N,T}\n\nReturn the values of the set s as a SmallVector.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.push-Tuple{AbstractSmallSet, Pair}","page":"Small sets","title":"SmallCollections.push","text":"push(s::AbstractSmallSet{N,T}, xs...) where {N,T} -> Tuple{SmallSet{N,T}, T}\n\nReturn the set that is obtained from s by adding the elements given as arguments.\n\nSee also Base.push!.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.pop-Tuple{AbstractSmallSet}","page":"Small sets","title":"SmallCollections.pop","text":"pop(s::AbstractSmallSet{N,T}) where {N,T} -> Tuple{SmallSet{N,T}, T}\n\nRemove an element x from s and return the new set together with x. The set s must not be empty.\n\nSee also Base.pop!.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.pop-Tuple{AbstractSmallSet, Any}","page":"Small sets","title":"SmallCollections.pop","text":"pop(s::AbstractSmallSet{N,T}, x) where {N,T} -> Tuple{SmallSet{N,T}, T}\n\nRemove the element x from s and return the new set together with the stored element equal to x.\n\nSee also Base.pop!, delete.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.pop-Tuple{AbstractSmallSet, Any, Any}","page":"Small sets","title":"SmallCollections.pop","text":"pop(s::AbstractSmallSet{N,T}, x, default::U) where {N,T,U} -> Tuple{SmallSet{N,T}, Union{T,U}}\n\nIf s has the element x, remove it and return the new set together with the stored element equal to x. Otherwise return the tuple (SmallSet(d), default).\n\nSee also Base.pop!.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.delete-Tuple{AbstractSmallSet, Any}","page":"Small sets","title":"SmallCollections.delete","text":"delete(s::AbstractSmallSet{N,T}, x) where {N,T} -> SmallSet{N,T}\n\nRemove the element x from s (if it exists) and return the new set.\n\nSee also Base.delete!, pop.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.sum_fast-Tuple{AbstractSmallSet}","page":"Small sets","title":"SmallCollections.sum_fast","text":"sum_fast(s::AbstractSmallSet{N,T}) where {N,T}\n\nReturn the @fastmath sum of the elements of s. Unlike for sum, the return value always is of the element type of s, even for small bit integers.\n\nSee also Base.sum, Base.@fastmath.\n\n\n\n\n\n","category":"method"},{"location":"smallset/#SmallCollections.extrema_fast-Tuple{AbstractSmallSet}","page":"Small sets","title":"SmallCollections.extrema_fast","text":"extrema_fast(s::AbstractSmallSet; [init])\n\nReturn the @fastmath minimum and maximum of the elements of s. The init keyword argument may not be used.\n\nSee also Base.extrema, Base.@fastmath.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#sec-abstractfixedvector","page":"Fixed-length vectors","title":"Fixed-length vectors","text":"","category":"section"},{"location":"fixedvector/#SmallCollections.AbstractFixedVector","page":"Fixed-length vectors","title":"SmallCollections.AbstractFixedVector","text":"AbstractFixedVector{N,T} <: AbstractVector{T}\n\nAbstractFixedVector{N,T} is the supertype of FixedVector{N,T} and MutableFixedVector{N,T}.\n\nSee also FixedVector, MutableFixedVector.\n\n\n\n\n\n","category":"type"},{"location":"fixedvector/#SmallCollections.FixedVector","page":"Fixed-length vectors","title":"SmallCollections.FixedVector","text":"FixedVector{N,T} <: AbstractFixedVector{N,T}\n\nFixedVector{N,T}(iter)\nFixedVector{N}(iter)\nFixedVector(iter)\n\nFixedVector{N,T} is an immutable vector type that holds exactly N elements of type T. (It is analogous to StaticArrays.SVector and StaticVectors.Values.) The size N can be any (small) positive integer. However, at least for bit integer and hardware float types, one usually takes N to be a power of 2.\n\nIf the element type T or the size N are omitted, they are determined from the iterator given as argument. Performance degrades if this is not possible at compile time. (For tuples, the element type is determined via promote_type.) As a rule of thumb, the size should only be omitted for Tuple arguments.\n\nSee also MutableFixedVector, Base.promote_type.\n\n\n\n\n\nFixedVector(v::StaticVector{N,T}) where {N,T} -> FixedVector{N,T}\nMutableFixedVector(v::StaticVector{N,T}) where {N,T} -> MutableFixedVector{N,T}\n\nConvert a StaticVector to a FixedVector or MutableFixedVector. The length N is inferred from the given vector v. For example, v can be an SVector or MVector.\n\nThese methods are only available if the package StaticArrays.jl is loaded.\n\nSee also AbstractFixedVector, StaticArrays.StaticVector.\n\n\n\n\n\n","category":"type"},{"location":"fixedvector/#SmallCollections.MutableFixedVector","page":"Fixed-length vectors","title":"SmallCollections.MutableFixedVector","text":"MutableFixedVector{N,T} <: AbstractFixedVector{N,T}\n\nMutableFixedVector{N,T}(iter)\nMutableFixedVector{N}(iter)\nMutableFixedVector(iter)\n\nMutableFixedVector{N,T}(undef)\n\nMutableFixedVector{N,T} is a mutable vector type that holds exactly N elements of type T. (It is analogous to StaticArrays.MVector and StaticVectors.Variables.) The size N can be any (small) positive integer. However, at least for bit integer and hardware float types, one usually takes N to be a power of 2.\n\nIf the element type T or the size N are omitted, they are determined from the iterator given as argument. Performance degrades if this is not possible at compile time. As a rule of thumb, the size should only be omitted for Tuple arguments.\n\nNote that setting individual vector elements (via setindex!) is only supported for isbits element types.\n\nThe special form MutableFixedVector{N,T}(undef) returns a non-initialized vector.\n\nSee also FixedVector, Base.isbitstype.\n\n\n\n\n\nFixedVector(v::StaticVector{N,T}) where {N,T} -> FixedVector{N,T}\nMutableFixedVector(v::StaticVector{N,T}) where {N,T} -> MutableFixedVector{N,T}\n\nConvert a StaticVector to a FixedVector or MutableFixedVector. The length N is inferred from the given vector v. For example, v can be an SVector or MVector.\n\nThese methods are only available if the package StaticArrays.jl is loaded.\n\nSee also AbstractFixedVector, StaticArrays.StaticVector.\n\n\n\n\n\n","category":"type"},{"location":"fixedvector/#SmallCollections.fixedvector-Tuple{AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.fixedvector","text":"fixedvector(v::AbstractFixedVector{N,T}) where {N,T} -> FixedVector{N,T}\n\nReturns the argument as a FixedVector. The purpose of this function is to make is easier to write code that works for both AbstractFixedVector and AbstractSmallVector.\n\nSee also fixedvector(::AbstractSmallVector).\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.bits-Tuple{AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.bits","text":"bits(v::AbstractFixedVector{N,T}) where {N, T <: Union{Base.HWReal, Bool, Char, Enum}} -> Unsigned\n\nConvert the given vector to an unsigned integer.\n\nFor bit integers, hardware floats, Char and Enum types this is the same as reinterpret(U, Tuple(v)) provided that U is an unsigned integer type with N*bitsize(T) bits, possibly defined by the package BitIntegers. Otherwise the result will be zero-extended to the next unsigned integer type U whose bit length is a power of 2.\n\nIf the element type is Bool, then each element only takes one bit in the return value. If N is less than 8 or not a power of 2, then the result will again be zero-extended.\n\nThe inverse operation can be done with convert.\n\nSee also Base.convert, SmallCollections.bitsize, Base.HWReal, Base.reinterpret, BitIntegers.\n\nExamples\n\njulia> FixedVector{4,Int8}(1:4) |> bits\n0x04030201\n\njulia> FixedVector{3}('a':'c') |> bits\n0x00000000630000006200000061000000\n\njulia> m = FixedVector{6,UInt32}(1:6) |> bits\n0x0000000000000000000000060000000500000004000000030000000200000001\n\njulia> typeof(m)\nBitIntegers.UInt256\n\njulia> FixedVector{22}(map(isodd, 1:22)) |> bits\n0x00155555\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#Base.convert-Union{Tuple{V}, Tuple{T}, Tuple{N}, Tuple{Type{V}, Unsigned}} where {N, T<:Union{Bool, Char, Float32, Float64, Int16, Int32, Int64, Int8, UInt16, UInt32, UInt64, UInt8, Enum}, V<:AbstractFixedVector{N, T}}","page":"Fixed-length vectors","title":"Base.convert","text":"convert(::Type{V}, x::Unsigned) where {N, T <: Union{Base.HWReal, Bool, Char, Enum}, V <: AbstractFixedVector{N,T}}\n\nConvert the unsigned integer x to a FixedVector{N,T} or MutableFixedVector{N,T}. The bits of x are split into groups of size bitsize(T) and reinterpreted as elements of type T. Unused bits are ignored and missing bits are taken as 0. This is the inverse operation to bits.\n\nSee also bits, SmallCollections.bitsize, Base.HWReal, BitIntegers.\n\nExamples\n\njulia> v = convert(FixedVector{4,Int8}, 0x030201)\n4-element FixedVector{4, Int8}:\n 1\n 2\n 3\n 0\n\njulia> bits(v)\n0x00030201\n\njulia> convert(FixedVector{6,Bool}, 0xf0)\n6-element FixedVector{6, Bool}:\n 0\n 0\n 0\n 0\n 1\n 1\n\njulia> x = FixedVector{2,Char}('a':'b') |> bits\n0x6200000061000000\n\njulia> convert(FixedVector{2,Char}, x)\n2-element FixedVector{2, Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n\njulia> using BitIntegers\n\njulia> convert(FixedVector{4,Int64}, uint256\"0x300000000000000020000000000000001\")\n4-element FixedVector{4, Int64}:\n 1\n 2\n 3\n 0\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.fasthash-Tuple{AbstractFixedVector, UInt64}","page":"Fixed-length vectors","title":"SmallCollections.fasthash","text":"fasthash(v::AbstractFixedVector [, h0::UInt]) -> UInt\n\nReturn a hash for v that may be computed faster than the standard hash for vectors. This new hash is consistent across all AbstractFixedVectors of the same element type, but it may not be compatible with hash or with fasthash for a AbstractFixedVector having a different element type.\n\nCurrently, fasthash differs from hash only if the element type of v is a bit integer type with at most 32 bits, Bool or Char.\n\nSee also Base.hash.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#Base.setindex-Tuple{AbstractFixedVector, Any, Integer}","page":"Fixed-length vectors","title":"Base.setindex","text":"setindex(v::AbstractFixedVector{N,T}, x, i::Integer) where {N,T} -> FixedVector{N,T}\n\nSubstitute x for the i-th component of v and return the result. The vector v is not modified.\n\nSee also Base.setindex,  addindex.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.addindex-Tuple{AbstractFixedVector, Any, Integer}","page":"Fixed-length vectors","title":"SmallCollections.addindex","text":"addindex(v::AbstractFixedVector{N,T}, x, i::Integer) where {N,T} -> FixedVector{N,T}\n\nAdd x to the i-th component of v and return the result. The vector v is not modified.\n\nSee also setindex.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#Base.circshift-Tuple{AbstractFixedVector, Union{Integer, Val}}","page":"Fixed-length vectors","title":"Base.circshift","text":"circshift(v::AbstractFixedVector{N,T}, k::Integer) -> FixedVector{N,T}\ncircshift(v::AbstractFixedVector{N,T}, ::Val{k}) where k -> FixedVector{N,T}\n\nRotate v by k positions towards higher indices and return the result. A negative value of k corresponds to a rotation towards lower indices.\n\nSee also [circshift!](@ref circshift!(::MutableFixedVector, ::Union{Integer,Val}).\n\nExamples\n\njulia> v = FixedVector{4}(1:4);\n\njulia> circshift(v, 1)\n4-element FixedVector{4, Int64}:\n 4\n 1\n 2\n 3\n\njulia> circshift(v, Val(-1))\n4-element FixedVector{4, Int64}:\n 2\n 3\n 4\n 1\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#Base.circshift!-Tuple{MutableFixedVector, Union{Integer, Val}}","page":"Fixed-length vectors","title":"Base.circshift!","text":"circshift!(v::MutableFixedVector{N,T}, k::Integer) -> v\ncircshift!(v::MutableFixedVector{N,T}, ::Val{k}) where k -> v\n\nRotate v in-place by k positions towards higher indices and return v. A negative value of k corresponds to a rotation towards lower indices.\n\nSee also [circshift](@ref circshift(::AbstractFixedVector, ::Union{Integer,Val}).\n\nExamples\n\njulia> v = MutableFixedVector{4}(1:4);\n\njulia> circshift!(v, 1)\n4-element MutableFixedVector{4, Int64}:\n 4\n 1\n 2\n 3\n\njulia> circshift!(v, Val(-1))  # undo previous step\n4-element MutableFixedVector{4, Int64}:\n 1\n 2\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.sum_fast-Tuple{AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.sum_fast","text":"sum_fast(v::AbstractFixedVector)\n\nReturn the @fastmath sum of the elements of v. Unlike for sum, the return value always is of the element type of v, even for small bit integers.\n\nSee also Base.sum, Base.@fastmath.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.extrema_fast-Tuple{AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.extrema_fast","text":"extrema_fast(v::AbstractFixedVector; [init])\n\nReturn the @fastmath minimum and maximum of the elements of v. The init keyword argument may not be used.\n\nSee also Base.extrema, Base.@fastmath.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.extrema_fast-Tuple{Any, AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.extrema_fast","text":"extrema_fast(f, v::AbstractFixedVector; [init])\n\nReturn the @fastmath minimum and maximum of the values of f applied to the elements of v. The init keyword argument may not be used.\n\nSee also Base.extrema, Base.@fastmath.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#Base.any-Tuple{Function, AbstractFixedVector}","page":"Fixed-length vectors","title":"Base.any","text":"any(f::Function, v::AbstractFixedVector; dims = :, [style::MapStyle])\nall(f::Function, v::AbstractFixedVector; dims = :, [style::MapStyle])\nallequal(f, v::AbstractFixedVector; [style::MapStyle})\nallunique(f, v::AbstractFixedVector; [style::MapStyle])\nfindfirst(f::Function, v::AbstractFixedVector; [style::MapStyle])\nfindlast(f::Function, v::AbstractFixedVector; [style::MapStyle])\nfindnext(f::Function, v::AbstractFixedVector, k::Integer; [style::MapStyle])\nfindprev(f::Function, v::AbstractFixedVector, k::Integer; [style::MapStyle])\n\nWith an AbstractFixedVector v as second argument, these functions accept the additional keyword argument style. If it equals LazyStyle(), then the function f is only evaluated until the result has been determined. For any other value of style, f is evaluated on all elements of v. This is often faster for simple functions.\n\nAs discussed under MapStyle, the default value for style is based on a list of known functions.\n\nSee also SmallCollections.MapStyle.\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.support-Tuple{AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.support","text":"support(v::AbstractFixedVector) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the non-zero elements of v. If v has Bool elements, then this means the elements that are true.\n\nSee also SmallBitSet, support(::Any, ::AbstractFixedVector).\n\nExample\n\njulia> v = FixedVector{4,Int8}([1, 0, 0, 3]);\n\njulia> support(v)\nSmallBitSet{UInt8} with 2 elements:\n  1\n  4\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#SmallCollections.support-Tuple{Any, AbstractFixedVector}","page":"Fixed-length vectors","title":"SmallCollections.support","text":"support(f, v::AbstractFixedVector) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the elements x of v for which f(x) is non-zero. If f has Bool values, then this means that f(x) has to be true.\n\nSee also SmallBitSet, support(::AbstractFixedVector).\n\nExample\n\njulia> v = FixedVector{4,Int8}(3:6);\n\njulia> support(isodd, v)\nSmallBitSet{UInt8} with 2 elements:\n  1\n  3\n\n\n\n\n\n","category":"method"},{"location":"fixedvector/#StaticArraysCore.SVector","page":"Fixed-length vectors","title":"StaticArraysCore.SVector","text":"SVector(v::AbstractFixedVector{N,T}) where {N,T} -> SVector{N,T}\nMVector(v::AbstractFixedVector{N,T}) where {N,T} -> MVector{N,T}\n\nConvert an AbstractFixedVector to an SVector or MVector. The length N is inferred from the argument.\n\nThese methods are only available if the package StaticArrays.jl is loaded.\n\nSee also StaticArrays.SVector, StaticArrays.MVector, AbstractFixedVector.\n\n\n\n\n\n","category":"type"},{"location":"capacityvector/#sec-abstractsmallvector","page":"Small and packed vectors","title":"Small and packed vectors","text":"","category":"section"},{"location":"capacityvector/#SmallCollections.AbstractCapacityVector","page":"Small and packed vectors","title":"SmallCollections.AbstractCapacityVector","text":"AbstractCapacityVector{T} <: AbstractVector{T}\n\nAbstractCapacityVector is the supertype of the variable-length vector types provided by this module. At present, these are AbstractSmallVector and PackedVector. Both can hold a variable number of elements up to a predefined maximal capacity. If the element type T is concrete, then the immutable vector types do not allocate.\n\nSee also AbstractSmallVector, PackedVector.\n\n\n\n\n\n","category":"type"},{"location":"capacityvector/#SmallCollections.capacity-Tuple{Type{<:AbstractCapacityVector}}","page":"Small and packed vectors","title":"SmallCollections.capacity","text":"capacity(::Type{<:AbstractCapacityVector}) -> Int\ncapacity(v::AbstractCapacityVector) -> Int\n\nReturn the largest number of elements this vector type can hold.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.empty-Tuple{AbstractCapacityVector}","page":"Small and packed vectors","title":"Base.empty","text":"empty(v::V) where V <: AbstractCapacityVector -> V\n\nReturn an empty AbstractCapacityVector of the same type as v.\n\nSee also empty(v::AbstractSmallVector, ::Type),  empty(v::PackedVector, ::Type).\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.zeros","page":"Small and packed vectors","title":"Base.zeros","text":"zeros(::Type{V}, n::Integer) where V <: AbstractCapacityVector -> V\n\nReturn an AbstractCapacityVector of type V containing n zeros.\n\nSee also ones.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#Base.ones","page":"Small and packed vectors","title":"Base.ones","text":"ones(::Type{V}, n::Integer) where V <: AbstractCapacityVector -> V\n\nReturn a AbstractCapacityVector of type V containing n ones.\n\nSee also zeros.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#Base.setindex-Tuple{AbstractCapacityVector, Any, Integer}","page":"Small and packed vectors","title":"Base.setindex","text":"setindex(v::V, x, i::Integer) where V <: AbstractCapacityVector -> V\n\nSubstitute x for the i-th component of v and return the new vector.\n\nSee also Base.setindex,  addindex.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.addindex-Tuple{AbstractCapacityVector, Any, Integer}","page":"Small and packed vectors","title":"SmallCollections.addindex","text":"addindex(v::V, x, i::Integer) where V <: AbstractCapacityVector -> V\n\nAdd x to the i-th component of v and return the new vector.\n\nSee also setindex.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.push-Tuple{AbstractCapacityVector, Vararg}","page":"Small and packed vectors","title":"SmallCollections.push","text":"push(v::V, xs...) where V <: AbstractCapacityVector -> V\n\nReturn the AbstractCapacityVector obtained from v by appending the arguments xs.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.pop-Tuple{AbstractCapacityVector}","page":"Small and packed vectors","title":"SmallCollections.pop","text":"pop(v::V) where {T, V <: AbstractCapacityVector{T}} -> Tuple{V,T}\n\nReturn the tuple (w, x) where x is the last element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.pushfirst","page":"Small and packed vectors","title":"SmallCollections.pushfirst","text":"pushfirst((v::V, xs...) where V <: AbstractCapacityVector -> V\n\nReturn the AbstractCapacityVector obtained from v by prepending the arguments xs.\n\nSee also Base.pushfirst!, BangBang.pushfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.popfirst","page":"Small and packed vectors","title":"SmallCollections.popfirst","text":"popfirst(v::V) where {T, V <: AbstractCapacityVector{T}} -> Tuple{V,T}\n\nReturn the tuple (w, x) where x is the first element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.popfirst!, BangBang.popfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.insert","page":"Small and packed vectors","title":"SmallCollections.insert","text":"insert(v::V, i::Integer, x) where V <: AbstractCapacityVector{T} -> V\n\nReturn the AbstractCapacityVector obtained from v by inserting x at position i. The position i must be between 1 and length(v)+1.\n\nThis is the non-mutating analog of Base.insert!.\n\nSee also duplicate.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.duplicate","page":"Small and packed vectors","title":"SmallCollections.duplicate","text":"duplicate(v::V, i::Integer, x) where V <: AbstractCapacityVector{T} -> V\n\nDuplicate the i-th entry of v by inserting it at position i+1 and return the new vector.\n\nSee also insert.\n\nExample\n\njulia> v = SmallVector{8,Int8}(1:3)\n3-element SmallVector{8, Int8}:\n 1\n 2\n 3\n\njulia> duplicate(v, 2)\n4-element SmallVector{8, Int8}:\n 1\n 2\n 2\n 3\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.deleteat","page":"Small and packed vectors","title":"SmallCollections.deleteat","text":"deleteat(v::V, i::Integer) where V <: AbstractCapacityVector -> V\n\nReturn the AbstractCapacityVector obtained from v by deleting the element at position i. The latter must be between 1 and length(v).\n\nSee also Base.deleteat!, BangBang.deleteat!!.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.popat","page":"Small and packed vectors","title":"SmallCollections.popat","text":"popat(v::V, i::Integer) where {T, V <: AbstractCapacityVector{T}} -> Tuple{V,T}\n\nReturn the tuple (w, x) where w obtained from v by deleting the element x at position i. The latter must be between 1 and length(v).\n\nSee also Base.popat!, BangBang.popat!!.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.append","page":"Small and packed vectors","title":"SmallCollections.append","text":"append(v::V, ws...) where V <: AbstractCapacityVector -> V\n\nAppend all elements of the collections ws to v and return the new vector. Note that the resulting AbstractCapacityVector has the same capacity as v.\n\nSee also Base.append!, BangBang.append!!.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.prepend","page":"Small and packed vectors","title":"SmallCollections.prepend","text":"prepend(v::V, ws...) where V <: AbstractCapacityVector -> V\n\nPrepend all elements of the collections ws to v and return the new vector. Note that the resulting AbstractCapacityVector has the same capacity as v.\n\nSee also Base.prepend!.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.support-Tuple{AbstractCapacityVector}","page":"Small and packed vectors","title":"SmallCollections.support","text":"support(v::AbstractCapacityVector) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the non-zero elements of v. If v has Bool elements, then this means the elements that are true.\n\nSee also SmallBitSet, support(::Any, ::AbstractSmallVector).\n\nExample\n\njulia> v = SmallVector{8,Int8}([1, 0, 2, 0, 0, 3]);\n\njulia> support(v)\nSmallBitSet{UInt8} with 3 elements:\n  1\n  3\n  6\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#sec-smallvector","page":"Small and packed vectors","title":"Small vectors","text":"","category":"section"},{"location":"capacityvector/#SmallCollections.AbstractSmallVector","page":"Small and packed vectors","title":"SmallCollections.AbstractSmallVector","text":"AbstractSmallVector{N,T} <: AbstractVector{T}\n\nAbstractSmallVector{N,T} is the supertype of SmallVector{N,T} and MutableSmallVector{N,T}.\n\nSee also SmallVector, MutableSmallVector.\n\n\n\n\n\n","category":"type"},{"location":"capacityvector/#SmallCollections.SmallVector","page":"Small and packed vectors","title":"SmallCollections.SmallVector","text":"SmallVector{N,T} <: AbstractSmallVector{N,T}\n\nSmallVector{N,T}()\nSmallVector{N,T}(iter)\nSmallVector{N}(iter)\nSmallVector(v::PackedVector{T})\nSmallVector(v::AbstractSmallVector)\n\nSmallVector{N,T} is an immutable vector type that can hold up to N elements of type T. Here N can be any (small) positive integer. However, at least for bit integer and hardware float types, one usually takes N to be a power of 2.\n\nThe element type T can be omitted when creating the SmallVector from an iterator that has an element type, for example from an AbstractVector or a tuple. In the latter case, T is determined by promoting the element types of the tuple. If no argument is given, then an empty vector is returned. If the SmallVector is created from an AbstractSmallVector or PackedVector v and the parameter N is omitted, then it is set to capacity of v.\n\nThe unused elements of a SmallVector{N,T} are filled with the value default(T), which is predefined for several types including Number. Default values for other types must be defined explicitly.\n\nAddition and subtraction of two SmallVectors is possible even if the vectors have different capacity. (Of course, their lengths must agree.) The capacity of the result is the smaller of the arguments' capacities in this case.\n\nSee also MutableSmallVector, capacity, SmallCollections.default, Base.IteratorEltype, promote_type.\n\nExamples\n\njulia> v = SmallVector{8,Int8}(2*x for x in 1:3)\n3-element SmallVector{8, Int8}:\n 2\n 4\n 6\n\njulia> w = SmallVector{9}((1, 2.5, 4))\n3-element SmallVector{9, Float64}:\n 1.0\n 2.5\n 4.0\n\njulia> v+w\n3-element SmallVector{8, Float64}:\n  3.0\n  6.5\n 10.0\n\n\n\n\n\n","category":"type"},{"location":"capacityvector/#SmallCollections.MutableSmallVector","page":"Small and packed vectors","title":"SmallCollections.MutableSmallVector","text":"MutableSmallVector{N,T} <: AbstractSmallVector{N,T}\n\nMutableSmallVector{N,T}()\nMutableSmallVector{N,T}(iter)\nMutableSmallVector{N}(iter)\nMutableSmallVector(v::PackedVector{T})\nMutableSmallVector(v::AbstractSmallVector)\n\nMutableSmallVector{N,T}(undef, n::Integer)\n\nMutableSmallVector{N,T} is a mutable vector type that can hold up to N elements of type T. It is the mutable analog of SmallVector{N,T}.\n\nNote that setting individual vector elements (via setindex!) is only supported for isbits element types.\n\nThe special form MutableSmallVector{N,T}(undef, n) returns a non-initialized vector of length n.\n\nSee also SmallVector, Base.isbitstype.\n\n\n\n\n\n","category":"type"},{"location":"capacityvector/#SmallCollections.fixedvector-Tuple{AbstractSmallVector}","page":"Small and packed vectors","title":"SmallCollections.fixedvector","text":"fixedvector(v::AbstractSmallVector{N,T}) where {N,T} -> FixedVector{N,T}\n\nReturn the FixedVector underlying v. It agrees with v at all positions up to length(v); the remaining elements are equal to default(T).\n\nSee also SmallCollections.default, fixedvector(::AbstractFixedVector).\n\nExample\n\njulia> v = SmallVector{4}(1:2)\n2-element SmallVector{4, Int64}:\n 1\n 2\n\njulia> fixedvector(v)\n4-element FixedVector{4, Int64}:\n 1\n 2\n 0\n 0\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.bits-Tuple{AbstractSmallVector}","page":"Small and packed vectors","title":"SmallCollections.bits","text":"bits(v::AbstractSmallVector) -> Unsigned\n\nReturn the bit representation of fixedvector(v).\n\nSee also fixedvector, bits(::AbstractFixedVector).\n\nExample\n\njulia> SmallVector{4,Int8}(1:3) |> bits\n0x00030201\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.empty-Tuple{AbstractSmallVector, Type}","page":"Small and packed vectors","title":"Base.empty","text":"empty(v::AbstractSmallVector{N}, S::Type) where {N,S} -> AbstractSmallVector{N,S}\n\nReturn an empty AbstractSmallVector with the same capacity as v and element type U. The resulting vector is mutable if and only if v is so.\n\nSee also empty(v::AbstractCapacityVector).\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.unsafe_copyto!-Union{Tuple{N}, Tuple{MutableSmallVector{N}, AbstractSmallVector{N}}} where N","page":"Small and packed vectors","title":"Base.unsafe_copyto!","text":"unsafe_copyto!(w::MutableSmallVector{N}, v::AbstractSmallVector{N}) where N -> w\n\nCopy the vector v to w. Both are assumed to have the same length.\n\nSee also unsafe_copyto!(::MutableSmallVector{N}, ::Union{AbstractFixedVector{N},NTuple{N}}) where N\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.unsafe_copyto!-Union{Tuple{N}, Tuple{MutableSmallVector{N}, Union{NTuple{N, T} where T, AbstractFixedVector{N}}}} where N","page":"Small and packed vectors","title":"Base.unsafe_copyto!","text":"unsafe_copyto!(w::MutableSmallVector{N}, v::Union{AbstractFixedVector{N},NTuple{N}}) where N -> w\n\nCopy the vector or tuple v to w. The length of w is not changed. The elements in v past the length of w are assumed to be default values.\n\nSee also unsafe_copyto!(::MutableSmallVector{N}, ::AbstractSmallVector{N}) where N, SmallCollections.default.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.resize","page":"Small and packed vectors","title":"SmallCollections.resize","text":"resize(v::AbstractSmallVector{N,T}, n::Integer) -> SmallVector{N,T}\n\nReturn a vector of length n by making v longer or shorter. If the new vector is longer, then the new elements are initialized with default(T).\n\nSee also Base.resize!, SmallCollections.default.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.fasthash-Tuple{AbstractSmallVector, UInt64}","page":"Small and packed vectors","title":"SmallCollections.fasthash","text":"fasthash(v::AbstractSmallVector [, h0::UInt]) -> UInt\n\nReturn a hash for v that may be computed faster than the standard hash for vectors. This new hash is consistent across all AbstractSmallVectors of the same element type, but it may not be compatible with hash or with fasthash for a AbstractSmallVector having a different element type.\n\nCurrently, fasthash differs from hash only if the element type of v is a bit integer type with at most 32 bits, Bool or Char.\n\nSee also fasthash(::PackedVector, ::UInt), Base.hash.\n\nExamples\n\njulia> v = SmallVector{8,Int8}([1, 5, 6]);\n\njulia> fasthash(v)\n0x6466067ab41d0916\n\njulia> fasthash(v) == hash(v)\nfalse\n\njulia> w = SmallVector{16,Int8}(v); fasthash(v) == fasthash(w)\ntrue\n\njulia> w = SmallVector{8,Int16}(v); fasthash(v) == fasthash(w)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.sum_fast-Tuple{AbstractSmallVector}","page":"Small and packed vectors","title":"SmallCollections.sum_fast","text":"sum_fast(v::AbstractSmallVector{N,T}) where {N,T}\n\nReturn the @fastmath sum of the elements of v. Unlike for sum, the return value always is of the element type of v, even for small bit integers.\n\nSee also Base.sum, Base.@fastmath.\n\nExample\n\njulia> v = SmallVector{4}([-0.0, -0.0])\n2-element SmallVector{4, Float64}:\n -0.0\n -0.0\n\njulia> sum(v), sum_fast(v)\n(-0.0, 0.0)\n\njulia> v = SmallVector{4}(Int8[80, 90])\n2-element SmallVector{4, Int8}:\n 80\n 90\n\njulia> sum(v), sum_fast(v)\n(170, -86)\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.extrema_fast-Tuple{AbstractSmallVector}","page":"Small and packed vectors","title":"SmallCollections.extrema_fast","text":"extrema_fast(v::AbstractSmallVector; [init])\n\nReturn the @fastmath minimum and maximum of the elements of v. The init keyword argument may not be used.\n\nSee also Base.extrema, Base.@fastmath.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.any-Tuple{Function, AbstractSmallVector}","page":"Small and packed vectors","title":"Base.any","text":"any(f::Function, v::AbstractSmallVector; dims = :, [style::MapStyle])\nall(f::Function, v::AbstractSmallVector; dims = :, [style::MapStyle])\nallequal(f, v::AbstractSmallVector; [style::MapStyle})\nallunique(f, v::AbstractSmallVector; [style::MapStyle])\nfindall(f::Function, v::AbstractSmallVector; [style::MapStyle])\nfindfirst(f::Function, v::AbstractSmallVector; [style::MapStyle])\nfindlast(f::Function, v::AbstractSmallVector; [style::MapStyle])\nfindnext(f::Function, v::AbstractSmallVector, k::Integer; [style::MapStyle])\nfindprev(f::Function, v::AbstractSmallVector, k::Integer; [style::MapStyle])\ncount(f, v::AbstractSmallVector; dims = :, init = 0, [style::MapStyle])\n\nWith an AbstractSmallVector v as second argument, these functions accept the additional keyword argument style. If it equals LazyStyle(), then the function f is only evaluated until the result has been determined. For any other value of style, f is evaluated on all elements of v as well as on the default values used for padding. This is often faster for simple functions.\n\nAs discussed under MapStyle, the default value for style is based on a list of known functions.\n\nSee also SmallCollections.default, SmallCollections.MapStyle.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.map","page":"Small and packed vectors","title":"Base.map","text":"map(f, v::AbstractSmallVector...; [style::MapStyle]) -> SmallVector\n\nApply f to the argument vectors elementwise and stop when one of them is exhausted. Note that the capacity of the resulting SmallVector is the minimum of the argument vectors' capacities.\n\nThe style keyword argument determines how map treats the padding used for AbstractSmallVector. As discussed under MapStyle, the default value is based on a list of known functions.\n\nSee also capacity, Base.map(f, v::AbstractVector...), SmallCollections.MapStyle, Section \"Broadcasting\".\n\nExamples\n\njulia> v = SmallVector{8}(1:3); w = SmallVector{4}(2.0:4.0); map(*, v, w)\n3-element SmallVector{4, Float64}:\n  2.0\n  6.0\n 12.0\n\njulia> v = SmallVector{8}('a':'e'); w = SmallVector{4}('x':'z'); map(*, v, w)\n3-element SmallVector{4, String}:\n \"ax\"\n \"by\"\n \"cz\"\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.support-Tuple{Any, AbstractSmallVector}","page":"Small and packed vectors","title":"SmallCollections.support","text":"support(f, v::AbstractSmallVector; [style::MapStyle]) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the elements x of v for which f(x) is non-zero. If f has Bool values, then this means that f(x) has to be true.\n\nThe style keyword argument determines how the padding used for AbstractSmallVector is treated. As discussed under MapStyle, the default value is based on a list of known functions.\n\nSee also SmallBitSet, support(::AbstractSmallVector), SmallCollections.MapStyle.\n\nExample\n\njulia> v = SmallVector{8,Int8}(3:8);\n\njulia> support(isodd, v)\nSmallBitSet{UInt8} with 3 elements:\n  1\n  3\n  5\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#sec-packedvector","page":"Small and packed vectors","title":"Packed vectors","text":"","category":"section"},{"location":"capacityvector/#SmallCollections.PackedVector","page":"Small and packed vectors","title":"SmallCollections.PackedVector","text":"PackedVector{U<:Unsigned,M,T<:Union{Base.BitInteger,Bool}} <: AbstractCapacityVector{T}\n\nPackedVector{U,M,T}()\nPackedVector{U,M,T}(iter)\nPackedVector{U,M}(v::AbstractVector{T})\nPackedVector{U,M}(t::Tuple)\nPackedVector(v::AbstractSmallVector{M,T})\n\nThis type of immutable vector stores the elements in a common bit mask of type U with M bits for each entry. The range of allowed values is -2^(M-1):2^(M-1)-1 if T <: Signed, 0:2^M-1 if T <: Unsigned and false:true if T == Bool. Apart from that, the official element type T is only used when retrieving an entry.  The capacity, that is, the number of elements that can be stored, is given by bitsize(U)Ã·M.\n\nThe element type T can be omitted when creating the PackedVector from an AbstractVector or from a tuple. In the latter case, T is determined by promoting the element types of the tuple. If no argument is given, then an empty vector is returned. If the PackedVector is created from a AbstractSmallVector v and the parameters U and M are omitted, then M is set to bitsize(T) and U is chosen such that the capacity of the resulting vector is at least the capacity of v.\n\nOverflow or underflow during addition or subtraction of vectors do not throw an error. The same applies to multiplication by a scalar of type T. Scalar multiplication by other types returns a Vector.\n\nCompared to a SmallVector, a PackedVector may have faster insert and delete operations. Arithmetic operations are usually slower unless M is the size of a hardware integer.\n\nSee also capacity, SmallCollections.bitsize.\n\nExamples\n\njulia> v = PackedVector{UInt64,5,Int8}(-5:5:10)\n4-element PackedVector{UInt64, 5, Int8}:\n -5\n  0\n  5\n 10\n\njulia> capacity(v)\n12\n\njulia> w = PackedVector{UInt64,5,Int8}([1, 2, 3, 4])\n4-element PackedVector{UInt64, 5, Int8}:\n 1\n 2\n 3\n 4\n\njulia> v+w\n4-element PackedVector{UInt64, 5, Int8}:\n -4\n  2\n  8\n 14\n\njulia> Int8(2)*v\n4-element PackedVector{UInt64, 5, Int8}:\n -10\n   0\n  10\n -12\n\n\n\n\n\n","category":"type"},{"location":"capacityvector/#SmallCollections.bits-Tuple{PackedVector}","page":"Small and packed vectors","title":"SmallCollections.bits","text":"bits(v::PackedVector{U}) where U -> U\n\nReturn the bit mask used internally to store the elements of the vector v.\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#Base.empty-Tuple{PackedVector, Type}","page":"Small and packed vectors","title":"Base.empty","text":"empty(v::PackedVector{U,M}, S::Type) where {U,M,S} -> PackedVector{U,M,S}\n\nReturn an empty PackedVector with the same bit mask type and same bit size as v, but element type S.\n\nSee also empty(v::AbstractCapacityVector).\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.fasthash-Tuple{PackedVector, UInt64}","page":"Small and packed vectors","title":"SmallCollections.fasthash","text":"fasthash(v::PackedVector [, h0::UInt]) -> UInt\n\nReturn a hash for v that may be computed faster than the standard hash for vectors. This new hash is consistent across all PackedVector{U,M,T} of the same internal bit size M, but it may not be compatible with hash or with fasthash for a PackedVector having a different bit size. However, using fasthash for two PackedVectors with the same M, but both signed and unsigned element types T may lead to hash collisions.\n\nSee also fasthash(::AbstractSmallVector, ::UInt), Base.hash.\n\nExamples\n\njulia> v = PackedVector{UInt64,5,Int8}([1, 5, 6]);\n\njulia> fasthash(v)\n0x11e89b9d8f3daac6\n\njulia> fasthash(v) == hash(v)\nfalse\n\njulia> w = PackedVector{UInt128,5,Int8}(v); fasthash(v) == fasthash(w)\ntrue\n\njulia> w = PackedVector{UInt64,4,Int8}(v); fasthash(v) == fasthash(w)\nfalse\n\njulia> w = PackedVector{UInt64,5,UInt8}(v); fasthash(v) == fasthash(w)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"capacityvector/#SmallCollections.unsafe_add","page":"Small and packed vectors","title":"SmallCollections.unsafe_add","text":"SmallCollections.unsafe_add(v::V, w::V) where V <: PackedVector -> V\n\nAdd v and w and return the result. It is not checked that v and w have the same length. No overflow or underflow is allowed in any component, nor are sign changes in the case of signed integers.\n\nThis function is much faster than regular addition.\n\nSee also unsafe_sub.\n\n\n\n\n\n","category":"function"},{"location":"capacityvector/#SmallCollections.unsafe_sub","page":"Small and packed vectors","title":"SmallCollections.unsafe_sub","text":"SmallCollections.unsafe_sub(v::V, w::V) where V <: PackedVector -> V\n\nSubtract w from v and return the result. It is not checked that v and w have the same length. No overflow or underflow  is allowed in any component, nor are sign changes in the case of signed integers.\n\nThis function is much faster than regular addition.\n\nSee also unsafe_add.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.jl","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"","category":"section"},{"location":"#SmallCollections","page":"SmallCollections.jl","title":"SmallCollections","text":"SmallCollections\n\nThis packages provides several mutable and immutable collections that can hold a fixed or limited (small) number of elements and are much more efficient than Set and Vector, for example. This applies in particular to the immutable variants because they don't allocate if isbitstype holds for the element type. At present, FixedVector, SmallVector, SmallDict and SmallSet and their mutable counterparts are defined as well as PackedVector and SmallBitSet.\n\nThe submodule Combinatorics contains functions related to enumerative combinatorics.\n\nIf the package BangBang.jl is loaded, then many functions defined by this package are also available in !!-form. For example, setindex!! with a SmallVector as first argument calls setindex.\n\nBounds checking can be skipped for the functions defined in this package by using the @inbounds macro.\n\nSee AbstractFixedVector, AbstractSmallDict, AbstractSmallSet, AbstractSmallVector, PackedVector, SmallBitSet, Combinatorics, Base.@inbounds, Base.isbitstype, Section \"BangBang support\".\n\n\n\n\n\n","category":"module"},{"location":"smallbitset/#sec-smallbitset","page":"Small bit sets","title":"Small bit sets","text":"","category":"section"},{"location":"smallbitset/#SmallCollections.SmallBitSet","page":"Small bit sets","title":"SmallCollections.SmallBitSet","text":"SmallBitSet{U<:Unsigned} <: AbstractSet{Int}\n\nSmallBitSet{U}([iter])\nSmallBitSet([iter])\n\nSmallBitSet{U} is an immutable set that can hold integers between 1 and the bit length of U. Called without an argument, it returns an empty set. If U is omitted, then UInt is taken.\n\nAll non-mutating functions for sets are supported. The non-mutating analogs push, pop and delete of the corresponding !-functions are also provided.\n\n\n\n\n\n","category":"type"},{"location":"smallbitset/#SmallCollections.bits-Tuple{SmallBitSet}","page":"Small bit sets","title":"SmallCollections.bits","text":"bits(s::SmallBitSet{U}) where U -> U\n\nReturn the bit mask used internally to store the elements of the set s.\n\nSee also convert(::Type{SmallBitSet}, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#Base.convert-Tuple{Type{SmallBitSet}, Integer}","page":"Small bit sets","title":"Base.convert","text":"convert(::Type{SmallBitSet{U}}, mask::Integer) where U -> SmallBitSet{U}\nconvert(::Type{SmallBitSet}, mask::Integer) -> SmallBitSet{UInt}\n\nConvert a bit mask to a SmallBitSet of the given type. This is the inverse operation to bits.\n\nSee also bits.\n\nExamples\n\njulia> s = SmallBitSet{UInt16}([1, 5, 6]);\n\njulia> u = bits(s)\n0x0031\n\njulia> convert(SmallBitSet, u)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  5\n  6\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.capacity-Tuple{Type{<:SmallBitSet}}","page":"Small bit sets","title":"SmallCollections.capacity","text":"capacity(::Type{<:SmallBitSet}) -> Int\ncapacity(s::SmallBitSet) -> Int\n\nReturn the largest number that the given set or SmallBitSet type can store.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.fasthash-Tuple{SmallBitSet, UInt64}","page":"Small bit sets","title":"SmallCollections.fasthash","text":"fasthash(s::SmallBitSet [, h0::UInt]) -> UInt\n\nReturn a hash for s that can be computed fast. This hash is consistent across all SmallBitSets, but it is not compatible with the hash used for sets.\n\nSee also Base.hash.\n\nExamples\n\njulia> s = SmallBitSet(1:3);\n\njulia> fasthash(s)\n0x828a4cc485149963\n\njulia> fasthash(s) == hash(s)\nfalse\n\njulia> t = SmallBitSet{UInt16}(s);\n\njulia> fasthash(s) == fasthash(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#Base.empty-Tuple{SmallBitSet}","page":"Small bit sets","title":"Base.empty","text":"empty(s::S) where S <: SmallBitSet -> S\n\nReturn an empty SmallBitSet of the same type as s.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.push-Tuple{SmallBitSet, Vararg}","page":"Small bit sets","title":"SmallCollections.push","text":"push(s::S, xs...) where S <: SmallBitSet -> S\n\nReturn the SmallBitSet obtained from s by adding the other arguments xs.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.pop-Tuple{SmallBitSet}","page":"Small bit sets","title":"SmallCollections.pop","text":"pop(s::S) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where x is the smallest element from s and t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.pop-Tuple{SmallBitSet, Any}","page":"Small bit sets","title":"SmallCollections.pop","text":"pop(s::S, x) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.pop-Tuple{SmallBitSet, Any, Any}","page":"Small bit sets","title":"SmallCollections.pop","text":"pop(s::S, x, default::T) where S <: SmallBitSet -> Tuple{S, Union{Int,T}}\n\nIf s contains x, return the pair (t, x) where t is the set s with x deleted. Otherwise return (s, default)\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.delete-Tuple{SmallBitSet, Any}","page":"Small bit sets","title":"SmallCollections.delete","text":"delete(s::S, x) where S <: SmallBitSet -> S\n\nIf s contains x, return the set obtained by deleting that element. Otherwise return s.\n\nSee also Base.delete!, BangBang.delete!!.\n\n\n\n\n\n","category":"method"},{"location":"smallbitset/#SmallCollections.exchange","page":"Small bit sets","title":"SmallCollections.exchange","text":"exchange(s::S, i::Integer, j::Integer) where S <: SmallBitSet -> S\n\nReturn the set s with the element i, if present, replaced by j and vice versa. If i equals j, then the set is not modified.\n\nThis function is faster than the equivalent replace(s, i => j, j => i).\n\nSee also Base.replace.\n\nExamples\n\njulia> s = SmallBitSet((1, 2)); exchange(s, 1, 2)\nSmallBitSet{UInt64} with 2 elements:\n  1\n  2\n\njulia> s = SmallBitSet((1, 2)); exchange(s, 2, 3)\nSmallBitSet{UInt64} with 2 elements:\n  1\n  3\n\njulia> s = SmallBitSet((1, 2)); exchange(s, 3, 4)\nSmallBitSet{UInt64} with 2 elements:\n  1\n  2\n\njulia> s = SmallBitSet((1, 2)); exchange(s, 1, 1)\nSmallBitSet{UInt64} with 2 elements:\n  1\n  2\n\n\n\n\n\n","category":"function"},{"location":"smallbitset/#Base.any-Tuple{Function, SmallBitSet}","page":"Small bit sets","title":"Base.any","text":"any(f::Function, s::SmallBitSet{U}; [style::MapStyle]) where U\nall(f::Function, s::SmallBitSet{U}; [style::MapStyle]) where U\ncount(f, s::SmallBitSet{U}; init = 0, [style::MapStyle]) where U\nfilter(f, s::SmallBitSet{U}; [style::MapStyle]) where U\n\nWith a SmallBitSet s as second argument, these functions accept the additional keyword argument style. If it equals LazyStyle(), then the function f is only evaluated for elements of s. For any other value of style, f is evaluated on all numbers between 1 and the bit size of U. This is often faster for simple functions.\n\nAs discussed under MapStyle, the default value for style is based on a list of known functions.\n\nSee also SmallCollections.MapStyle.\n\n\n\n\n\n","category":"method"}]
}
