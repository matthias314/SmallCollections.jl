var documenterSearchIndex = {"docs":
[{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"DocTestSetup = quote\n        using SmallCollections\n    # for jldoctest outside of docstrings\n    end","category":"page"},{"location":"#SmallCollections.jl","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections","category":"page"},{"location":"#SmallCollections","page":"SmallCollections.jl","title":"SmallCollections","text":"SmallCollections\n\nThis packages provides several immutable collections that don't allocate and are therefore faster than the usual types. The number of elements that these collections can hold is necessarily limited. At present SmallBitSet and SmallVector are defined.\n\nIf the package BangBang.jl is loaded, then many functions defined by this package are also available in !!-form. For example, setindex!! with a SmallVector as first argument calls setindex.\n\nSee SmallBitSet, SmallVector.\n\n\n\n\n\n","category":"module"},{"location":"#sec-smallvector","page":"SmallCollections.jl","title":"SmallVector","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallVector\ncapacity(::Type{<:SmallVector{N}}) where N\nfasthash(::SmallVector, ::UInt)\nempty\nzeros(::Type{<:SmallVector}, ::Integer)\nones(::Type{<:SmallVector}, ::Integer)\nsetindex\npush(::SmallVector, ::Vararg{Any})\npop(::SmallVector)\npushfirst\npopfirst\ninsert\ndeleteat\npopat\nsupport","category":"page"},{"location":"#SmallCollections.SmallVector","page":"SmallCollections.jl","title":"SmallCollections.SmallVector","text":"SmallVector{N,T} <: AbstractVector{T}\n\nSmallVector{N,T}(iter)\nSmallVector{N}(v::AbstractVector{T})\nSmallVector{N}(t::Tuple)\n\nSmallVector{N,T} is an immutable vector type that can hold up to N elements of type T. Here N can be any (small) positive integer. However, at least for bit integer and hardware float types, one usually takes N to be a power of 2.\n\nThe element type T can be omitted when creating the SmallVector from an AbstractVector or from a tuple. In the latter case, T is determined by promoting the element types of the tuple.\n\nThe unused elements of a SmallVector{N,T} are filled with the value default(T). This is pre-defined for number types, Char, String and Symbol. For other types it must be set explicitly.\n\nAddition and subtraction of two SmallVectors is possible even if the vectors have different capacity. (Of course, their lengths must agree.) The capacity of the result is the smaller of the arguments' capacities in this case.\n\nSee also capacity, SmallCollections.default, promote_type.\n\nExamples\n\njulia> v = SmallVector{8,Int8}(2*x for x in 1:3)\n3-element SmallVector{8, Int8}:\n 2\n 4\n 6\n\njulia> w = SmallVector{9}((1, 2.5, 4))\n3-element SmallVector{9, Float64}:\n 1.0\n 2.5\n 4.0\n\njulia> v+w\n3-element SmallVector{8, Float64}:\n  3.0\n  6.5\n 10.0\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.capacity-Union{Tuple{Type{<:SmallVector{N}}}, Tuple{N}} where N","page":"SmallCollections.jl","title":"SmallCollections.capacity","text":"capacity(::Type{<:SmallVector{N}}) where N -> N\ncapacity(v::SmallVector{N}) where N -> N\n\nReturn N, which is the largest number of elements this vector type can hold.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.fasthash-Tuple{SmallVector, UInt64}","page":"SmallCollections.jl","title":"SmallCollections.fasthash","text":"fasthash(v::SmallVector [, h0::UInt]) -> UInt\n\nReturn a hash for v that may be computed faster than the standard hash for vectors. This new hash is consistent across all SmallVectorss of the same element type, but it may not be compatible with hash or with fasthash for a SmallVector having a different element type.\n\nCurrently, fasthash differs from hash only if the element type of v is a bit integer type with at most 32 bits, Bool or Char.\n\nSee also Base.hash.\n\nExamples\n\njulia> v = SmallVector{8,Int8}([1, 5, 6]);\n\njulia> fasthash(v)\n0x6466067ab41d0916\n\njulia> fasthash(v) == hash(v)\nfalse\n\njulia> w = SmallVector{16,Int8}(v); fasthash(v) == fasthash(w)\ntrue\n\njulia> w = SmallVector{8,Int16}(v); fasthash(v) == fasthash(w)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty","page":"SmallCollections.jl","title":"Base.empty","text":"empty(v::V) where V <: SmallVector -> V\n\nReturn an empty SmallVector of the same type as v.\n\n\n\n\n\n","category":"function"},{"location":"#Base.zeros-Tuple{Type{<:SmallVector}, Integer}","page":"SmallCollections.jl","title":"Base.zeros","text":"zeros(::Type{V}, n::Integer) where V <: SmallVector -> V\n\nReturn a SmallVector of type V containing n zeros.\n\nSee also ones(::Type{<:SmallVector}, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"#Base.ones-Tuple{Type{<:SmallVector}, Integer}","page":"SmallCollections.jl","title":"Base.ones","text":"ones(::Type{V}, n::Integer) where V <: SmallVector -> V\n\nReturn a SmallVector of type V containing n ones.\n\nSee also zeros(::Type{<:SmallVector}, ::Integer).\n\n\n\n\n\n","category":"method"},{"location":"#Base.setindex","page":"SmallCollections.jl","title":"Base.setindex","text":"setindex(v::V, x, i::Integer) where V <: SmallVector -> V\n\nReturn a vector that agrees with v except possibly for the i-th entry that is set to x.\n\nSee also Base.setindex.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.push-Tuple{SmallVector, Vararg{Any}}","page":"SmallCollections.jl","title":"SmallCollections.push","text":"push(v::SmallVector{N,T}, xs...) where {N,T} -> SmallVector{N,T}\n\nReturn the SmallVector obtained from v by appending the other arguments xs. The length of v must be less than N.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallVector}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(v::SmallVector{N,T}) where {N,T} -> Tuple{SmallVector{N,T},T}\n\nReturn the tuple (w, x) where x is the last element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pushfirst","page":"SmallCollections.jl","title":"SmallCollections.pushfirst","text":"pushfirst(v::SmallVector{N,T}, xs...) where {N,T} -> SmallVector{N,T}\n\nReturn the SmallVector obtained from v by prepending the other arguments xs. The length of v must be less than N.\n\nSee also Base.pushfirst!, BangBang.pushfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.popfirst","page":"SmallCollections.jl","title":"SmallCollections.popfirst","text":"popfirst(v::SmallVector{N,T}) where {N,T} -> Tuple{SmallVector{N,T},T}\n\nReturn the tuple (w, x) where x is the first element of v and w obtained from v by dropping this element. The vector v must not be empty.\n\nSee also Base.popfirst!, BangBang.popfirst!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.insert","page":"SmallCollections.jl","title":"SmallCollections.insert","text":"insert(v::SmallVector{N,T}, i::Integer, x) where {N,T} -> SmallVector{N,T}\n\nReturn the SmallVector obtained from v by inserting x at position i. The position i must be between 1 and length(v)+1, and length(v) must be less than N.\n\nThis is the non-mutating analog of Base.insert!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.deleteat","page":"SmallCollections.jl","title":"SmallCollections.deleteat","text":"deleteat(v::V, i::Integer) where V <: SmallVector -> V\n\nReturn the SmallVector obtained from v by deleting the element at position i. The position i must be between 1 and length(v).\n\nSee also Base.deleteat!, BangBang.deleteat!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.popat","page":"SmallCollections.jl","title":"SmallCollections.popat","text":"popat(v::SmallVector{N,T}, i::Integer) where {N,T} -> Tuple{SmallVector{N,T},T}\n\nReturn the tuple (w, x) where w obtained from v by deleting the element x at position i. The latter must be between 1 and length(v).\n\nSee also Base.popat!, BangBang.popat!!.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.support","page":"SmallCollections.jl","title":"SmallCollections.support","text":"support(v::SmallVector) -> SmallBitSet\n\nReturn the SmallBitSet with the indices of the non-zero elements of v.\n\nSee also SmallBitSet.\n\nExample\n\njulia> v = SmallVector{8,Int8}([1, 0, 2, 0, 0, 3]);\n\njulia> support(v)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  3\n  6\n\n\n\n\n\n","category":"function"},{"location":"#sec-smallbitset","page":"SmallCollections.jl","title":"SmallBitSet","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallBitSet\nbits\nconvert(::Type{SmallBitSet}, ::Integer)\ncapacity(::Type{<:SmallBitSet})\nfasthash(::SmallBitSet, ::UInt)\npush(::SmallBitSet, ::Vararg{Any})\npop(::SmallBitSet)\npop(::SmallBitSet, ::Any)\npop(::SmallBitSet, ::Any, ::Any)\ndelete","category":"page"},{"location":"#SmallCollections.SmallBitSet","page":"SmallCollections.jl","title":"SmallCollections.SmallBitSet","text":"SmallBitSet{U<:Unsigned} <: AbstractSet{Int}\n\nSmallBitSet{U}([iter])\nSmallBitSet([iter])\n\nSmallBitSet{U} is an immutable set that can hold integers between 1 and the bit length of U. Called without an argument, it returns an empty set. If U is omitted, then UInt is taken.\n\nAll non-mutating functions for sets are supported. The non-mutating analogs push, pop and delete of the corresponding !-functions are also provided.\n\n\n\n\n\n","category":"type"},{"location":"#SmallCollections.bits","page":"SmallCollections.jl","title":"SmallCollections.bits","text":"bits(s::SmallBitSet{U}) where U -> U\n\nReturn the bit mask used internally to store the elements of the set s.\n\nSee also convert(::Type{SmallBitSet}, ::Integer).\n\n\n\n\n\n","category":"function"},{"location":"#Base.convert-Tuple{Type{SmallBitSet}, Integer}","page":"SmallCollections.jl","title":"Base.convert","text":"convert(::Type{SmallBitSet{U}}, mask::Integer) where U -> SmallBitSet{U}\nconvert(::Type{SmallBitSet}, mask::Integer) -> SmallBitSet{UInt}\n\nConvert a bit mask to a SmallBitSet of the given type. This is the inverse operation to bits.\n\nSee also bits.\n\nExamples\n\njulia> s = SmallBitSet{UInt16}([1, 5, 6]);\n\njulia> u = bits(s)\n0x0031\n\njulia> convert(SmallBitSet, u)\nSmallBitSet{UInt64} with 3 elements:\n  1\n  5\n  6\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.capacity-Tuple{Type{<:SmallBitSet}}","page":"SmallCollections.jl","title":"SmallCollections.capacity","text":"capacity(::Type{<:SmallBitSet}) -> Int\ncapacity(s::SmallBitSet) -> Int\n\nReturn the largest number that the given set or SmallBitSet type can store.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.fasthash-Tuple{SmallBitSet, UInt64}","page":"SmallCollections.jl","title":"SmallCollections.fasthash","text":"fasthash(s::SmallBitSet [, h0::UInt]) -> UInt\n\nReturn a hash for s that can be computed fast. This hash is consistent across all SmallBitSets, but it is not compatible with the hash used for sets.\n\nSee also Base.hash.\n\nExamples\n\njulia> s = SmallBitSet(1:3);\n\njulia> fasthash(s)\n0x828a4cc485149963\n\njulia> fasthash(s) == hash(s)\nfalse\n\njulia> t = SmallBitSet{UInt16}(s);\n\njulia> fasthash(s) == fasthash(t)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.push-Tuple{SmallBitSet, Vararg{Any}}","page":"SmallCollections.jl","title":"SmallCollections.push","text":"push(s::S, xs...) where S <: SmallBitSet -> S\n\nReturn the SmallBitSet obtained from s by adding the other arguments xs.\n\nSee also Base.push!, BangBang.push!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where x is the smallest element from s and t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet, Any}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S, x) where S <: SmallBitSet -> Tuple{S, Int}\n\nReturn the pair (t, x) where t is the set s with x deleted. The set s must be non-empty.\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.pop-Tuple{SmallBitSet, Any, Any}","page":"SmallCollections.jl","title":"SmallCollections.pop","text":"pop(s::S, x, default::T) where S <: SmallBitSet -> Tuple{S, Union{Int,T}}\n\nIf s contains x, return the pair (t, x) where t is the set s with x deleted. Otherwise return (s, default)\n\nSee also Base.pop!, BangBang.pop!!.\n\n\n\n\n\n","category":"method"},{"location":"#SmallCollections.delete","page":"SmallCollections.jl","title":"SmallCollections.delete","text":"delete(s::S, x) where S <: SmallBitSet -> S\n\nIf s contains x, return the set obtained by deleting that element. Otherwise return s.\n\nSee also Base.delete!, BangBang.delete!!.\n\n\n\n\n\n","category":"function"},{"location":"#BangBang-support","page":"SmallCollections.jl","title":"BangBang support","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"If the package BangBang.jl is loaded, then the functions push, pop, delete, union, intersect, setdiff and symdiff for SmallBitSet as well as setindex, push, pushfirst,  pop, popfirst and deleteat for SmallVector are also available in !!-form. For example, setindex!! with a SmallVector as first argument calls setindex. (For some reason, BangBang.jl does not implement insert!!.) Moreover, add!!(v::SmallVector, w::SmallVector) is a synonym for v+w.","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"This allows to write efficient code that works for both mutable and immutable arguments. For example, the function","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"f!!(v, ws...) = foldl(add!!, ws; init = v)","category":"page"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"adds up its arguments, mutating the first argument v if possible.","category":"page"},{"location":"#Internal-functions","page":"SmallCollections.jl","title":"Internal functions","text":"","category":"section"},{"location":"","page":"SmallCollections.jl","title":"SmallCollections.jl","text":"SmallCollections.bitsize\nSmallCollections.default\nSmallCollections.top_set_bit","category":"page"},{"location":"#SmallCollections.bitsize","page":"SmallCollections.jl","title":"SmallCollections.bitsize","text":"SmallCollections.bitsize(T::Type) -> Int\n\nReturn the size of the internal binary representation of T in bits.\n\nSee also Base.sizeof.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.default","page":"SmallCollections.jl","title":"SmallCollections.default","text":"SmallCollections.default(::Type{T}) -> T\n\nReturn the default value of type T used for filling unused elements of a SmallVector. This must be defined as zero(T) if T supports algebraic operations. Otherwise it can be any value of type T.\n\nThis function has methods for number types, Char, String and Symbol. Methods for other types must be defined explicitly.\n\n\n\n\n\n","category":"function"},{"location":"#SmallCollections.top_set_bit","page":"SmallCollections.jl","title":"SmallCollections.top_set_bit","text":"SmallCollections.top_set_bit(x::Unsigned) -> Int\n\nReturn the position of the highest set bit in x (counting from 1), or return 0 if x is 0.\n\nThis function is analogous to Julia's internal function Base.top_set_bit, but it is also fast and correct for bit integers defined by BitIntegers.jl.\n\nSee also Base.top_set_bit.\n\n\n\n\n\n","category":"function"}]
}
